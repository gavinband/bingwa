<!DOCTYPE HTML PUBLIC "-//SoftQuad Software//DTD HoTMetaL PRO 6.0::19990601::extensions to HTML 4.0//EN" "hmpro6.dtd">
<HTML> 
	<HEAD> 
		<TITLE>The BGEN format</TITLE>
		<LINK HREF="style.css" REL="stylesheet">
	</HEAD> 
  <BODY ALINK="orange"> 
		 <!--#include virtual="/header.shtml" -->
		<div>
			<h2>A Binary GEN file format - BGEN</h2>
        <p>
        <b>This page documents version 1.2 of the BGEN format.</b>
        </p>
        <p>
            <h3>Change history</h3>
            <center>
            <table class="changes">
                <tr><th>Version</th><th>Date</th><th>Description</th></tr>
                <tr><td>v1.2</td><td>October 2014</td><td>Update which extends BGEN in several ways:
					<ol>
						<li>
							Support variable ploidy and explicit missing data.
						</li>
						<li>
							Support for multi-allelic variants (e.g. complex structural variants).
						</li>
						<li>
							Allow for control over file size by supporting genotype probabilities stored at configurable precision.
						</li>
						<li>
							Support storing a list of sample identifiers.
						</li>
					</ol>
				</td></tr>
                <tr><td>v1.1</td><td>March 2012</td><td>Update designed to cope with the long alleles present at indels and structural
					variants in recent releases of the 1000 genomes project.
                    Also, we use an altered scaling of probabilities to maximise stored precision.
					This version is backwards-compatible with v1.0, via the <em>Layout</em> flag documented below.</td></tr>
                <tr><td><a href="bgen_format_v1.0.html">v1.0</a></td><td>2009</td>
					<td>Initial version.</td></tr>
            </table>
		</center>
        </p>
		<h3>Background</h3>

			<p>
        		A <a href="http://www.stats.ox.ac.uk/%7Emarchini/software/gwas/file_format.html">GEN file</a> typically contains
             millions of floating-point numbers -- often in a fixed format -- stored in the file in a textual
             representation. For example, for a cohort of 1500 individuals, typed at 30000 SNPs, to store the AA, AB and BB
             genotype probabilities takes 1500 x 30000 x 3 = 135 million floating-point numbers. Consequently, programs
             which manipulate this data must spend a long time parsing the numbers to produce in-memory float or double
             quantities. For simple programs this time can dominate the program execution time.  </p> <p>
             This page describes a binary GEN file format (the "BGEN" format) which overcomes this problem. Tests show
             that using this binary format can achieve a file input speed increase of 5-10x.  Genotype data is stored compressed
			 and at limited precision, so that BGEN files typically take up less space than a
			 corresponding gzipped GEN file, at the cost of reduction in precision.
             </p>
             <p>
             In v1.1 the specification was updated to handle long alleles such as those
             present in the latest 1000 genomes release.  This version has been updated to handle
			 multi-allelic variants, configurable precision, variable ploidy, and the storage of sample identifiers.
			</p>
			<p>A C++ implementation of this file format is available in the "genfile" sublibrary of QCTOOL, available <a href="http://bitbucket.org/gavinband/qctool/">here</a>.
			<h2>Overview</h2>
			
			<p>
			A <em>BGEN</em> file consists of a header block, followed by a series of blocks called snp blocks.  The first four
			bytes of the file indicate the start position of the first snp block (relative to the fifth byte of the file).
			<p>
				<b>Note: All numbers in the file are stored as integers in little endian (least significant byte first)
                order.</b>  This choice coincides with the memory layout
                used on most common architectures. see the <a
                href="http://en.wikipedia.org/wiki/Endianness">wikipedia page</a> for more details.
			</p>
			<h2>Detailed specification</h2>
			<h3>The first four bytes</h3>
			<p>
			The first four bytes of the file encode an unsigned integer indicating the offset, relative to the 5th byte of the file, of the
            start of the first snp block (or the end of the file if there are 0 snp blocks). 
			For example, if this offset is 20 (the minimum possible because the header block always has size at least 20) then the snp blocks start at byte 25.
			</p>
			<center>
			<table class="filespec">
				<tr><th>No. of bytes</th><th>Description</th></tr>
				<tr><td>4</td><td>An unsigned integer <em>offset</em> indicating the offset, relative to the fifth
                   byte of the file, of the first byte of the first snp block (or the end of the file if there are no
                   snp blocks).
				<tr><th>4</th><th>TOTAL</th></tr>
			</table>
			</center>

			<h3>The header block</h3>
        <p>
			The header block contains global information about the file.
        </p>
        <table class="filespec">
				<tr><th>No. of bytes</th><th>Description</th></tr>
				<tr><td>4</td><td>An unsigned integer <em>L<sub>H</sub></em> indicating the length, in bytes, of the header block.
					This must not be larger than <em>offset</em>.</td></tr>
           <tr><td>4</td><td>An unsigned integer indicating the number of snp blocks stored in the file.</td></tr>
           <tr><td>4</td><td>An unsigned integer indicating the number of samples represented in the snp blocks in the file.</td></tr>
           <tr><td>4</td><td>Reserved.  (Writers should write 0 here, readers should ignore these bytes.)</td></tr>
           <tr><td><em>L<sub>H</sub></em>-20</td><td>Free data area.  This could be used to store, for example, identifying information about the file</td></tr>
           <tr><td>4</td><td>A set of <em>flags</em>, with bits numbered as for an unsigned integer.  See below for flag definitions.</td></tr>
				<tr><th><em>L<sub>H</sub></em></th><th>TOTAL</th></tr>
		</table>

        <h3>Header block -- flag definitions</h3>
        <p>
        The following flags can be contained in the <em>flags</em> field in the header block.
		<b>Note</b>: all bits not listed here must be set to 0.
        </p>
        <table class="filespec">
				<tr><th>Bit</th><th>Name</th><th>Value</th><th>Description</th></tr>
				<tr><td>0</td><td><em>CompressedSNPBlocks</em></td><td>0</td><td>Indicates SNP block probability data is not compressed.</td></tr>
				<tr><td></td><td></td><td>1</td><td>Indicates SNP block probability data is compressed using zlib's compress() function.</td></tr>
				<tr><td>3-4</td><td><em>Layout</em><br />(previously called <em>LongIds</em>)</td><td>0</td>
					<td>Indicates SNP blocks are layed out according to the <a href="bgen_format_v1.0.html">v1.0 spec</a>.
						This allows only single-character alleles.  <b>Use of this format is deprecated,
							in the sense that it should not be used for new files.</b>  We will remove this from a future version of the spec.</b>
						
					</td>
				</tr>
				<tr><td></td><td></td><td>1</td>
					<td>Indicates SNP blocks are layed out according to the <a hred="bgen_format_v1.1.html">v1.1 spec</a>.
						This allows for multiple characters in alleles and is supported in SNPTEST from 
				     <a href="https://mathgen.stats.ox.ac.uk/genetics_software/snptest/snptest.html">version 2.3.0</a>,
				    and in <a href="http://www.well.ox.ac.uk/~gav/qctool/qctool.html">QCTOOL</a> from version 1.1.
				</td></tr>
				<tr><td></td><td></td><td>2</td><td>Indicates SNP blocks are layed out according to version 1.2 of the spec
					(as described in this document).
					This format supports multiple alleles, phased and unphased genotypes, explicit specification
					of ploidy and missing data, and configurable levels of compression.<br />
					It is recommended that all new files are stored with <em>Layout</em>=2.
				</td></tr>
				<tr><td>31</td><td><em>SampleIdentifiers</em></td><td>0</td><td>Indicates sample identifiers are not stored in this file.</td></tr>
				<tr><td></td><td></td><td>1</td><td>Indicates a sample identifier block follows the header.  It is recommended
					that all new files are created with <em>SampleIdentifiers</em>=1.
			</table>

			<h3>Sample identifier block</h3>
			<p>
				If <em>SampleIdentifiers</em>=1, the header block is immediately followed by a sample identifier block.
			</p>
	        <table class="filespec">
				<tr><th>No. of bytes</th><th>Description</th></tr>
				<tr><td>4</td><td>An unsigned integer <em>L<sub>SI</sub></em> indicating the length in bytes of the sample identifier block.
					This must satisfy the constraint <em>L<sub>SI</sub></em>+<em>L<sub>H</sub></em> &leq; <em>offset</em>.</td></tr>
				<tr><td>2</td><td>An unsigned integer indicating the length <em>L<sub>s1</sub></em> of the identifier of sample 1.</td></tr>
				<tr><td><em>L<sub>s1</sub></em></td><td>Identifier of sample 1.</td></tr>
				<tr><td>2</td><td>An unsigned integer indicating the length <em>L<sub>s2</sub></em> of the identifier of sample 2.</td></tr>
				<tr><td><em>L<sub>s1</sub></em></td><td>Identifier of sample 2.</td></tr>
				<tr><td>...</td><td></td></tr>
				<tr><td>2</td><td>An unsigned integer indicating the length <em>L<sub>sN</sub></em> of the identifier of sample <em>N</em>.</td></tr>
				<tr><td><em>L<sub>sN</sub></em></td><td>Identifier of sample <em>N</em>.</td></tr>
				<tr><th><em>L<sub>SI</sub></em> = 4 + 2&times;<em>N</em> + &sum;<sub>n</sub><em>L<sub>sn</sub></em></th><th>TOTAL</th></tr>
			</table>
			<p>
				<em>Note:</em> BGEN format treats sample identifiers as a string of bytes,
				and does not impose any additional restrictions.  However, for the simplest interoperability with other
				software it is often sensible to restrict to ASCII alphanumeric characters, underscores, and full stop
				(e.g. for <a href="http://www.r-project.org">R</a>'s
				<a href="https://stat.ethz.ch/R-manual/R-devel/library/base/html/make.names.html">make.names</a> ).
			</p>
			

			<h3>SNP blocks</h3>
			<p>
				Following the header comes a sequence of 0 or more SNP blocks.
				The format of SNP blocks depends on the value of the <em>Layout</em> flag set in the header block.
				When <em>Layout</em>=0, SNP blocks are layed out as per the v1.0 spec, described <a href="bgen_format_v1.0.html">here</a>.)
				When <em>Layout</em>=1, SNP blocks are layed out as per the v1.1 spec, described <a href="bgen_format_v1.1.html">here</a>.)
				When <em>Layout</em>=2, SNP blocks are layed out as follows.
			</p>
			<table class="filespec" align="center">
				<thead>
				<tr><th>No. of bytes</th><th>Description</th></tr>
				</thead>
				<tbody>
				<tr><td>2</td><td>The length <em>L<sub>id</sub></em> of the variant identifier. (The variant identifier is intended to store e.g. chip
					manufacturer IDs for assayed SNPs).</td></tr>
				<tr><td><em>L<sub>id</sub></em></td><td>The variant identifier.</td></tr>
				<tr><td>2</td><td>The length <em>L<sub>rsid</sub></em> of the rsid.</td></tr>
				<td><em>L<sub>rsid</sub></em></td><td>The rsid.</td></tr>
				<tr><td>2</td><td>The length <em>L<sub>chr</sub></em> of the chromosome</td></tr>
				<tr><td><em>L<sub>chr</chr></em></td><td>The chromosome</td></tr>
				<tr><td>4</td><td>The variant position, encoded as an unsigned 32-bit integer.</td></tr>
				<tr><td>2</td><td>The number <em>K</em> of alleles, encoded as an unsigned 16-bit integer.</td></tr>
				<tr><td>4</td><td>The length <em>L<sub>a1</sub></em> of the first allele.</td></tr>
				<tr><td><em>L<sub>a1</sub></em></td><td>The first allele.</td></tr>
				<tr><td>4</td><td>The length <em>L<sub>a2</sub></em> of the second allele.</td></tr>
				<tr><td><em>L<sub>a2</sub></em></td><td>The second allele.</td></tr>
				<tr><td>...</td><td>...(possibly more alleles)...</td></tr>
				<tr><td>4</td><td>The length <em>L<sub>aK</sub></em> of the <em>K</em>th allele.</td></tr>
				<tr><td><em>L<sub>aK</sub></em></td><td>The <em>K</em>th allele.</td></tr>
				<tr><td><em>4</em></td><td>The length <em>D</em> of the (compressed or uncompressed) genotype probability data.
				<tr><td><em>D</em></td><td>Compressed or uncompressed genotype probability data for the variant.
					When <em>CompressedSNPBlocks</em>=0, this consists of the genotype probability data as defined below.
					When <em>CompressedSNPBlocks</em>=1, this consists of a 32-bit unsigned integer indicating the length of the
					uncompressed data, followed by the compressed data itself.  See below for details of how SNP probability data
					is stored.</td></tr>
				</tbody>
				<tfoot>
				<tr><th>16 + 4<em>K</em> + <em>L<sub>id</sub></em> + <em>L<sub>rsid</sub></em> + <em>L<sub>chr</sub></em>
					+ &sum;<sub>k</sub><em>L<sub>ak</sub></em> + <em>D</em></th><th>TOTAL</th></tr>
				</tfoot>
			</table>
		<h3>SNP genotype or haplotype probability data</h3>
		<p>
			<table class="filespec">
				<thead>
				<tr><th width='20%'>No. of bytes</th><th>Description</th></tr>
				</thead>
				<tbody>
				<tr><td>4</td><td>The number of individuals the row represents, hereafter denoted <em>N</em>.</td></tr>
				<tr><td>1</td><td>The minimum ploidy <em>P<sub>min</sub></em> of samples in the row.
				<tr><td>1</td><td>The maximum ploidy <em>P<sub>max</sub></em> of samples in the row.<br/>
				    A value of 0xFF (all bits set to 1) for <em>P<sub>min</sub></em> or <em>P<sub>max</sub></em> indicates that all probability
					data is missing for this row.  In this case both <em>P<sub>min</sub></em> and <em>P<sub>max</sub></em>
					should be set to 0xFF, and no further data is stored for the row.  Otherwise, the following further fields are stored:
				<tr><td><em>N</em></td><td>A list of <em>N</em> bytes, where the <em>n</em>th byte is an unsigned integer
					representing the ploidy of the <em>n</em>th sample.  A value of 0xFF
					indicates that probabilities for that sample are missing.
				</td></tr>
				<tr><td>1</td><td>Flag, denoted <em>Phased</em> indicating what is stored in the row.  The total number
					of probabilities stored is <em>N</em>&times;</em>Z</em>, where <em>Z</em> is the number of probabilities
					stored per sample as follows:</br />
					If <em>Phased</em>=1 the row stores one probability per allele (other than the first allele)
					per haplotype (e.g. to represent phased data).  Therefore <em>Z</em>=<em>H&times;(K-1)</em>
					in this case.<br />
					If <em>Phased</em>=0 the row stores one probability per possible genotype (other than
					the 'first' genotype where all alleles are the first allele), to represent unphased data.  There will be
					<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
						<mi>Z</mi><mo>=</mo>
						<mo>(</mo>
						<mfrac linethickness="0">
							<mi>H+K-1</mi>
							<mi>K-1</mi>
						</mfrac>
						<mo>)</mo>
						<mo>-</mo><mn>1</mn>
					</math>
					probabilities per sample.<br />
					Any other value for <em>Phased</em> is an error.
				</td></tr>
				<tr><td>1</td></td><td>Unsigned integer <em>B</em> representing the number of bits used to store
					each probability in this row</td></tr>
				<tr>
				<td>
					<em>N</em>&times;<em>Z</em>
				</td>
				<td>
					Probabilities for each possible haplotype (if <em>Phased</em>=1) or genotype (if <em>Phased</em>=0) for the samples.
					Each probability is stored in <em>B</em> bits.  Values are interpreted by linear interpolation between 0 and 1,
					i.e. value <em>b</em> corresponds to probability <em>b</em> / ( 2<sup>b</sup>-1 ).
					When storing the value, probabilities should be rounded to the nearest value of this form.
					Probabilities for samples with missing data (<em>P<sub>n</sub></em>=0xF) should be stored as 0.
					Probabilities are stored consecutively for samples 1, 2, ..., <em>N</em>. 
					For each sample the order of stored probabilities is described below.
				</td>
				</tr>
				</tbody>
				<tfoot>
				<tr><th>8+<em>N</em>&times;(<em>Z</em>+1)</th><th>TOTAL</th></tr>
				</tfoot>
			</table>
		</p>
		<h3>Per-sample order of stored probabilities</h3>
		<p>
			Consider a sample with ploidy <em>H</em> and a variant with <em>K</em> alleles.
        <p>
			For phased data, probabilities are stored in the
			order of haplotypes and then alleles, ie:
			<div class="displayFormula">
			<em>P<sub>12</sub></em>, <em>P<sub>13</sub></em>, ..., <em>P<sub>1K</sub></em>,
			<em>P<sub>22</sub></em>, ..., <em>P<sub>2K</sub></em>,
			..., 
			<em>P<sub>H2</sub></em>, ..., <em>P<sub>HK</sub></em>.
			</div>
			where <em>P<sub>ij</sub></em> is the probability that haplotype <em>i</em> has allele <em>j</em>.
			For each haplotype <em>i</em> the value <em>P<sub>i1</sub></em> is not stored; instead it is inferred as one minus the
			sum of other probabilities for that haplotype.  If values are stored in <em>B</em> bits, the maximum possible rounding error
			for one stored probability is 1/(2<sup><em>B</em>+1</sup>-2), but the maximum possible error in <em>P<sub>i1</sub></em> is
			(<em>K</em>-1)/(2<sup><em>B</em>+1</sup>-2).  For a desired accuracy of &epsilon; we therefore recommend choosing
			 <em>B</em> so that 2<sup><em>B+1</em></sup> &geq; (2+(<em>K</em>-1)/&epsilon;),
			 i.e. <em>B</em> &geq; log<sub>2</sub>(2+(<em>K</em>-1)/&epsilon;) - 1  so that this quantity is less than
			the desired accuracy.  For accuracy to <em>d</em> decimal places we need the values to be correct to within &epsilon; = 0.5&times;10<sup>-d</sup>.
			The following table gives appropriate values of <em>B</em> for different accuracies and allele counts.
        </p>
		<table class="printStyleTable">
			<thead>
				<tr><th></th><th>1dp</th><th>2dps</th><th>3dps</th><th>4dps</th></tr>
			</thead>
			<tbody>
				<tr><th><em>K</em>=2</th><td>4</td><td>7</td><td>10</td><td>14</td></tr>
				<tr><th><em>K</em>=3</th><td>5</td><td>8</td><td>11</td><td>15</td></tr>
				<tr><th><em>K</em>=4</th><td>5</td><td>9</td><td>12</td><td>15</td></tr>
				<tr><th><em>K</em>=5</th><td>6</td><td>9</td><td>12</td><td>16</td></tr>
			</tbody>
		</table>
        <p>
			For unphased data, the possible allelic configurations can be enumerated by considering all
			strings of length <em>H</em> in the alphabet <em>1, ..., K</em> sorted so that digits
			do not decrease across the string.  (The number of such strings equals the number of ways of
			putting <em>H</em> unlabelled things into <em>K</em> boxes, i.e.
			<math xmlns="http://www.w3.org/1998/Math/MathML" display="inline">
				<mo>(</mo>
				<mfrac linethickness="0">
					<mi>H+K-1</mi>
					<mi>K-1</mi>
				</mfrac>
				<mo>)</mo>
				<mo>-</mo><mn>1</mn>
			</math>
			).
			
			We store the probabilities in lexicographic order of these strings, omitting the first,
			e.g. for <em>H</em>=4:
			<div class="displayFormula">
			<em>P<sub>1112</sub></em>, <em>P<sub>1113</sub></em>, ..., <em>P<sub>111K</sub></em>,
			<em>P<sub>1122</sub></em>, <em>P<sub>1123</sub></em>, ..., <em>P<sub>112K</sub></em>,
			...,
			<em>P<sub>KKK1</sub></em>, ..., <em>P<sub>KKKK</sub></em>.
			</div>
			The value <em>P<sub>1111</sub></em> is not stored; instead it is inferred as one minus the
			sum of other probabilities for that sample.
			In particular for the common case of diploid chromosome and two alleles, <em>H</em>=2 and <em>K</em>=2, we store the
			probabilities <em>P</sub>12</sub></em> and <em>P</sub>22</sub></em>.
		</p>
		<h3>Converting probabilities to binary representation and back again</h3>
		<p>
			To convert a floating-point probability <em>x</em> to its binary representation in <em>B</em> bits, perform the following.
			<ol>
				<li>Multiply by 2<sup><em>B</em></sup>-1.</li>
				<li>Clamp to be in between 0 and 2<sup><em>B</em></sup>-1.</li>
				<li>Round to the nearest integer and store the least-significant <em>B</em> bits of the integral representation.</li>
			</ol>
			
			To convert a value stored in <em>B</em> bits to a floating-point probability,
			convert the unsigned integer to floating-point
			and divide by 2<sup><em>B</em></sup>-1.
		</p>
</body>
</html>
