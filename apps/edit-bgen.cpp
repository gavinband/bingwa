
//          Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#include <string>
#include <iostream>
#include <fstream>
#include <boost/filesystem.hpp>
#include <boost/format.hpp>
#include <boost/ptr_container/ptr_vector.hpp>
#include <algorithm>
#include "genfile/FileUtils.hpp"
#include "genfile/VariantIdentifyingData.hpp"
#include "genfile/Error.hpp"
#include "genfile/bgen/bgen.hpp"
#include "appcontext/CmdLineOptionProcessor.hpp"
#include "appcontext/OptionProcessor.hpp"
#include "appcontext/ApplicationContext.hpp"
#include "qctool_version_autogenerated.hpp"

namespace globals {
	std::string const program_name = "edit-bgen" ;
	std::string const program_version = qctool_revision ;
}

struct EditBgenOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;

		options.declare_group( "Input / output file options" ) ;
	    options[ "-g" ]
	        .set_description(
				"Path of bgen file(s) whose free data area to set. "
				"The free data area must have the same size in each bgen file."
			)
			.set_takes_values_until_next_option()
		;

	    options[ "-set-free-data" ]
	        .set_description(
				"Free data to set.  This must be a string exactly the length of the free data area in each file."
			)
			.set_takes_single_value()
			.set_is_required()
		;
	}
} ;

struct EditBgenApplication: public appcontext::ApplicationContext
{
public:
	EditBgenApplication( int argc, char** argv ):
		appcontext::ApplicationContext(
			globals::program_name,
			globals::program_version,
			std::auto_ptr< appcontext::OptionProcessor >( new EditBgenOptionProcessor ),
			argc,
			argv,
			"-log"
		)
	{
		process() ;
	}

	void process() {
		try {
			unsafe_process() ;
		}
		catch( genfile::MalformedInputError const& e ) {
			get_ui_context().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::BadArgumentError const& e ) {
			get_ui_context().logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	void unsafe_process() {
		std::string const free_data = options().get< std::string >( "-set-free-data" ) ;
		std::vector< std::string > filenames = options().get_values< std::string >( "-g" ) ;
		std::auto_ptr< boost::ptr_vector< std::fstream > > streams  = open_bgen_files( filenames, free_data ) ;
		edit_free_data( filenames, *streams, free_data ) ;
	}
	
	std::auto_ptr< boost::ptr_vector< std::fstream > > open_bgen_files( std::vector< std::string > const& filenames, std::string const& new_free_data ) const {
		boost::ptr_vector< std::fstream > streams ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			streams.push_back(
				std::auto_ptr< std::fstream >(
					new std::fstream(
						filenames[i].c_str(),
						std::ios::in | std::ios::out | std::ios::binary
					)
				)
			) ;
						
			// Verify header block has the right size.
			streams.back().seekg( 4 ) ;
			genfile::bgen::Context context ;
			genfile::bgen::read_header_block( streams.back(), &context ) ;
			if( context.free_data.size() != new_free_data.size() ) {
				throw genfile::BadArgumentError(
					"EditBgenApplication::unsafe_process()",
					"free_data=\"" + new_free_data + "\"",
					( boost::format( "In bgen file \"%s\": size of new free data (%d bytes) does not match that of free data in file (\"%s\", %d bytes)." )
						% filenames[i] % new_free_data.size() % context.free_data % context.free_data.size() ).str()
				) ;
			}
		}
		return streams.release() ;
	}
	
	void edit_free_data(
		std::vector< std::string > const& filenames,
		boost::ptr_vector< std::fstream >& streams,
		std::string const& free_data
	) const {
		assert( filenames.size() == streams.size() ) ;
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			edit_free_data( filenames[i], streams[i], free_data ) ;
		}
	}

	void edit_free_data( std::string const& filename, std::fstream& stream, std::string const& free_data ) const {
		get_ui_context().logger() << boost::format( "Setting free data for \"%s\" to \"%s\"..." ) % filename % free_data ;

		// Read (and double-check) the header
		// We checked this earlier, so assert if this fails.
		stream.seekg( 4 ) ;
		genfile::bgen::Context context ;
		genfile::bgen::read_header_block( stream, &context ) ;
		assert( context.free_data.size() == free_data.size() ) ;
		
		// free data always starts at byte 20.
		stream.seekp( 20, std::ios::beg ) ;
		stream.write( free_data.data(), free_data.size() ) ;
		stream.close() ;
		get_ui_context().logger() << "ok.\n" ;
	}
} ;

int main( int argc, char** argv ) {
    try {
		EditBgenApplication app( argc, argv ) ;
    }
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
