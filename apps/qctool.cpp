/*
 * This program, qctool, selects rows from a GEN file according to certain criteria.
 * - rows where some genotype data is missing, or none is.
 * - rows where genotype data is, or is not in hardy-weinberg equilibrium.
 * - rows with SNP IDs in a given list.
 *
 * Program arguments:
 *
 */

#include <string>
#include <map>
#include <set>
#include <fstream>
#include <memory>
#include <numeric>
#include <boost/bind.hpp>
#include <boost/shared_ptr.hpp>

#include "Timer.hpp"
#include "GenRow.hpp"
#include "SampleRow.hpp"
#include "appcontext/CmdLineOptionProcessor.hpp"
#include "RowCondition.hpp"
#include "SNPInListCondition.hpp"
#include "SNPIDMatchesCondition.hpp"
#include "SampleInListCondition.hpp"
#include "FileUtil.hpp"
#include "GenRowStatistics.hpp"
#include "SampleRowStatistics.hpp"
#include "ObjectSource.hpp"
#include "SimpleFileObjectSource.hpp"
#include "SimpleFileObjectSink.hpp"

#include "genfile/SNPDataSource.hpp"
#include "genfile/SNPDataSourceChain.hpp"
#include "genfile/SNPDataSourceRack.hpp"
#include "genfile/SNPDataSinkChain.hpp"
#include "genfile/TrivialSNPDataSink.hpp"
#include "genfile/CategoricalCohortIndividualSource.hpp"
#include "genfile/SampleFilteringCohortIndividualSource.hpp"
#include "genfile/CohortIndividualSourceChain.hpp"
#include "genfile/SampleFilteringSNPDataSource.hpp"
#include "genfile/SNPTranslatingSNPDataSource.hpp"
#include "genfile/StrandAligningSNPDataSource.hpp"
#include "genfile/AlleleFlippingSNPDataSource.hpp"
#include "genfile/VCFFormatSNPDataSource.hpp"
#include "genfile/Pedigree.hpp"
#include "genfile/PedFileSNPDataSink.hpp"
#include "genfile/BedFileSNPDataSink.hpp"
#include "genfile/CommonSNPFilter.hpp"
#include "genfile/SNPFilteringSNPDataSource.hpp"
#include "genfile/get_list_of_snps_in_source.hpp"
#include "genfile/utility.hpp"
#include "genfile/QuantileNormalisingCrossCohortCovariateValueMapping.hpp"
#include "genfile/ValueMappingCohortIndividualSource.hpp"
#include "genfile/vcf/StrictMetadataParser.hpp"

#include "statfile/BuiltInTypeStatSource.hpp"
#include "statfile/from_string.hpp"
#include "statfile/read_values.hpp"

#include "appcontext/appcontext.hpp"

#include "worker/QueuedMultiThreadedWorker.hpp"
#include "worker/SynchronousWorker.hpp"

#include "SampleOutputFile.hpp"
#include "GenotypeAssayStatisticFactory.hpp"
#include "string_utils/string_utils.hpp"
#include "string_utils/parse_utils.hpp"
#include "progress_bar.hpp"
#include "FileBackupCreator.hpp"
#include "InputToOutputFilenameMapper.hpp"
#include "OstreamTee.hpp"
#include "null_ostream.hpp"
#include "SNPPositionSink.hpp"
#include "SNPIDSink.hpp"
#include "statfile/RFormatStatSink.hpp"
#include "SampleIDSink.hpp"
#include "QCToolContext.hpp"
#include "QCTool.hpp"
#include "Relatotron.hpp"
#include "VCDBWriter.hpp"
#include "DataReadTest.hpp"
#include "ClusterFitter.hpp"
#include "KinshipCoefficientComputer.hpp"
#include "CallComparerComponent.hpp"
#include "ClusterPlotter.hpp"

#include "qctool_version_autogenerated.hpp"

#include "AssociationTester.hpp"

namespace globals {
	std::string const program_name = "qctool" ;
	std::string const program_version = qctool_revision ;
}

struct NumberOfSamplesMismatchException: public QCToolException
{
	char const* what() const throw() {return "NumberOfSamplesMismatchException" ; }
} ;

// Thrown to indicate that the numbers of input and output files specified on the command line differ.
struct QCToolFileCountMismatchError: public QCToolException
{
	char const* what() const throw() {return "QCToolFileCountMismatchError" ; }
} ;

struct QCToolOptionProcessor: public appcontext::CmdLineOptionProcessor
{
public:
	std::string get_program_name() const { return globals::program_name ; }

	void declare_options( appcontext::OptionProcessor& options ) {
		// Meta-options
		options.set_help_option( "-help" ) ;

		// File options	
		options.declare_group( "Input file options" ) ;
	    options[ "-g" ]
	        .set_description( 	"Path of gen file(s) to input.  "
								"The given filename may contain the wildcard character '#', which expands to match a"
								" two-character chromosome identifier.  (For example, \"qctool -g myfile_#.gen\" will find all files of "
								"the form \"myfile_01.gen\", \"myfile_02.gen\", etc.)  Only Human autosomes are matched this way.\n"
								"This option may be repeated, in which case each invocation is treated as a seperate cohort and cohorts"
								"are joined together to create one big dataset." )
			.set_takes_values_per_use( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 100 ) ;

	    options[ "-s" ]
	        .set_description( "Path of sample file to input.  If specified, this option must occur as often as the -g option"
							" to specify one sample file per cohort." )
			.set_takes_values_per_use( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;

/*	    options[ "-i" ]
	        .set_description( 	"Path of intensity file(s) to input.  "
								"If specified, this option must occur the same number of times as the -g option, to specify"
								" one intensity file per cohort."
								"As with -g the '#' wildcard character may be used to match chromosomes." )
			.set_takes_values_per_use( 1 )
			.set_minimum_multiplicity( 1 )
			.set_maximum_multiplicity( 100 ) ;
*/
		options.declare_group( "Sample exclusion options" ) ;
		options[ "-incl-samples"]
			.set_description( "Filter out samples whose sample ID does not lie in the given file.")
			.set_takes_values_per_use( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-samples"]
			.set_description( "Filter out samples whose sample ID lies in the given file.")
			.set_takes_values_per_use( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;

		options.declare_group( "Options for adjusting sample data" ) ;
		options[ "-quantile-normalise" ]
			.set_description( "Quantile normalise each specified continuous phenotype or covariate "
			 	"by ranking its values and mapping to quantiles of the standard normal distribution N(0,1). "
				"Ties are handled by sending tied values to the average of the corresponding quantiles."
				"The argument should be a comma-separated list of column names from the sample file." )
			.set_takes_single_value() ;
		options[ "-missing-code" ]
			.set_description( "Specify a comma-separated list of strings to be treated as missing values "
				"when encountered in the sample file(s)." )
			.set_takes_single_value()
			.set_default_value( "NA" ) ;
				
		options.option_implies_option( "-quantile-normalise", "-s" ) ;
		// SNP exclusion options
		options.declare_group( "SNP exclusion options" ) ;
		options[ "-excl-snpids" ]
			.set_description( "Exclude all SNPs whose SNPID is in the given file(s) from the analysis.")
			.set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-rsids" ]
			.set_description( "Exclude all SNPs whose RSID is in the given file(s) from the analysis.")
			.set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-snpids" ]
			.set_description( "Exclude all SNPs whose SNPID is not in the given file(s) from the analysis.")
			.set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-incl-rsids" ]
			.set_description( "Exclude all SNPs whose RSID is not in the given file(s) from the analysis.")
			.set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-excl-snps-matching" ]
			.set_description( "Filter out snps whose rsid or SNPID matches the given value. "
				"The value should be a string which can contain a % wildcard character (which matches any substring). "
				"If you use *, you should place the argument in quotes."
				"Optionally, prefix the argument with snpid~ or rsid~ to only match against the SNPID or rsid fields." )
			.set_takes_single_value() ;
		options[ "-incl-snps-matching" ]
			.set_description( "Filter out snps whose rsid or SNPID does not match the given value. "
				"The value should be a string which can contain a % wildcard character (which matches any substring). "
				"Optionally, prefix the argument with snpid~ or rsid~ to only match against the SNPID or rsid fields." )
			.set_takes_single_value() ;
		options[ "-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to operate on. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_single_value() ;
		options[ "-exclude-range" ]
			.set_description( "Specify a range of SNPs (or comma-separated list of ranges of SNPs) to exclude from operation. "
				"Each range should be in the format CC:xxxx-yyyy where CC is the chromosome and xxxx and yyyy are the "
				"start and end coordinates, or just xxxx-yyyy which matches that range from all chromosomes. "
				"You can also omit either of xxxx or yyyy to get all SNPs from the start or to the end of a chromosome." )
			.set_takes_single_value() ;
		options.declare_group( "Options for adjusting SNPs" ) ;
	    options[ "-strand" ]
	        .set_description( 	"Path of strand file(s) to input.  "
								"If specified, this option must occur the same number of times as the -g option, to specify"
								" one intensity file per cohort." )
			.set_takes_values_per_use( 1 )
			.set_minimum_multiplicity( 0 )
			.set_maximum_multiplicity( 100 ) ;
		options[ "-translate-snp-positions" ]
			.set_description( "Specify a \"dictionary\" of chromosome / position to chromosome / position mappings."
				" (This should come as a 12-column file with the first six columns the original SNPID rsid chromosome position allele1 allele2"
				" and the second six columns the same data with possibly different chromosome and position.)"
				" Positions of SNPs will be mapped through this dictionary before processing." )
			.set_takes_single_value() ;
		options[ "-match-alleles-to-cohort1" ]
			.set_description( "Specify that alleles (and corresponding genotypes) in all cohorts should be switched, if necessary,"
				" so as to match the alleles of the first cohort.  This does not perform allele complementation,"
				" but you can use the -strand option to complement alleles first." ) ;
		options[ "-snp-match-fields" ]
			.set_description( "By default, matching SNPs between cohorts uses all the available fields"
				" (position, rsid, SNPID, and alleles.)"
				" Use this option to specify a comma-separated subset of those fields to use instead."
				" The first entry must be \"position\"."
				" This option can be used, for example, when cohorts are typed on different platforms so have different SNPID fields." )
			.set_takes_single_value()
			.set_default_value( "position,rsid,SNPID,alleles" ) ;
		options[ "-assume-chromosome" ]
			.set_description( "Treat each SNP whose chromosome cannot be determined"
				" as though it lies on the specified chromosome." )
			.set_takes_single_value() ;

		options.declare_group( "Output file options" ) ;
	    options[ "-og" ]
	        .set_description( 	"Override the auto-generated path(s) of the output gen file(s) to use when filtering.  "
								"(By default, the paths are formed by adding \".fltrd\" to the input gen filename(s).)  "
								"If this option is supplied, it must appear the same number of times as the -g option. "
	 							"If the corresponding occurence of -g uses a '#' wildcard character, the '#' character can "
								"also be used here to specify numbered output files corresponding to the input files." )
	        .set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 1 ) ;

		options[ "-os" ]
	        .set_description( "Override the auto-generated path of the output sample file.  " )
	        .set_takes_single_value() ;

		options.declare_group( "Pedigree file options" ) ;
		options[ "-op" ]
			.set_description( "Output a pedigree file instead of a GEN-type file."
			 	" You must also input a pedigree using -ip for this to work." )
			.set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 1 ) ;
		options[ "-ip" ]
			.set_description( "Input a pedigree from the specified file."
			 	" The first six columns of this file should represent a PED format pedigree,"
				" according to the spec on the PLINK website.  (Other columns are ignored.)"
				" Ids are treated as non-whitespace strings and sex can be either"
				" \"1\" or \"M\" (male) or \"2\" or \"F\" (female) or \"other\"." )
			.set_takes_values_per_use( 1 )
			.set_maximum_multiplicity( 1 ) ;

		options.option_implies_option( "-op", "-ip" ) ;
		options.option_implies_option( "-op", "-s" ) ;

		// VCF file options
		options.declare_group( "VCF file options" ) ;
		options[ "-vcf-field-map" ]
			.set_description(
				"Specify a mapping of keys (such as \"genotypes\") which qctool will use internally, "
				"to values (such as \"GT\") which are present in the VCF file.  This allows flexibility in the choice "
				"of data used in a VCF file."
			)
			.set_takes_single_value()
			.set_default_value( "genotypes:GT" ) ;
		options[ "-metadata" ]
			.set_description(
				"Specify the name of a file containing VCF metadata to be used to parse "
				"a VCF file.  Keys in this file must either not be present in the VCF file, or must have "
				"identical values."
			)
			.set_takes_single_value() ;

		// Statistic file options
		options.declare_group( "Statistic calculation options" ) ;
	    options[ "-snp-stats" ]
			.set_description( "Calculate and output per-SNP statistics.  This implies that no SNP filtering options are used." ) ;
	    options[ "-snp-stats-file" ]
	        .set_description( 	"Override the auto-generated path(s) of the snp-stats file to use when outputting snp-wise statistics.  "
								"(By default, the paths are formed by adding \".snp-stats\" to the input gen filename(s).)  "
								"The '#' character can also be used here to specify one output file per chromosome." )
	        .set_takes_values_per_use(1)
			.set_maximum_multiplicity(1) ;

		options[ "-snp-stats-columns" ]
	        .set_description( "Comma-seperated list of extra columns to output in the snp-wise statistics file.  "
	 						"The standard columns are: "
							"SNPID, RSID, position, minor_allele, major_allele, MAF, HWE, missing, information."
							" Your choices here are old_information, jonathans_information, mach_r2, and entropy." )
			.set_takes_single_value()
			.set_default_value( "" ) ;

	    options[ "-sample-stats" ]
			.set_description( "Calculate and output sample-wise statistics." ) ;
		options[ "-sample-stats-columns" ]
	        .set_description( "Comma-seperated list of statistics to output in the sample-wise statistics file."
	 						 "  By default, the columns are: ID1, ID2, missing, and heterozygosity.")
			.set_takes_single_value()
			.set_default_value( std::string("ID1, ID2, missing, heterozygosity") ) ;
	    options[ "-sample-stats-file" ]
	        .set_description( 	"Override the auto-generated path of the file in which sample-wise statistics will be output." )
	        .set_takes_single_value() ;

		// SNP filtering options
		options.declare_group( "SNP filtering options" ) ;
		options[ "-hwe"]
			.set_description( "Filter out SNPs with -log10( HWE p-value ) greater than or equal to the value specified.")
			.set_takes_single_value() ;
		options[ "-info" ]
			.set_description( "Filter out SNPs with Fisher information lying outside the given range.")
			.set_takes_values_per_use( 2 ) ;
		options[ "-snp-missing-rate" ]
			.set_description( "Filter out SNPs with missing data rate greater than or equal to the value specified.")
			.set_takes_single_value() ;
		options[ "-missing-call-rate" ]
			.set_description( "Filter out SNPs with missing call rate greater than or equal to the value specified.")
			.set_takes_single_value() ;
		options[ "-snp-interval" ]
			.set_description( "Filter out SNPs with position outside the interval [a,b]." )
			.set_takes_values_per_use( 2 ) ;
		options[ "-maf" ]
			.set_description( "Filter out SNPs whose minor allele frequency lies outside the interval [a,b]." )
			.set_takes_values_per_use( 2 ) ;
			
		// Sample filtering options
		options.declare_group( "Sample filtering options" ) ;
		options[ "-sample-missing-rate" ]
			.set_description( "Filter out samples with missing data rate greater than the value specified.")
			.set_takes_single_value() ;
		options[ "-heterozygosity" ]
			.set_description( "Filter out samples with heterozygosity outside the inteval [a,b]." )
			.set_takes_values_per_use( 2 ) ;

		// Inclusion / exclusion list options
		options.declare_group( "Inclusion / exclusion list options" ) ;
		options[ "-write-sample-excl-list" ]
			.set_description( "Do not apply sample filters directly.  Instead, write a file containing a list of the ids"
			"  of individuals which would be filtered out by the filter." ) ;
		options[ "-write-sample-excl-list-file" ]
			.set_description( "Override default name of the file to use in -write-sample-excl-list" )
			.set_takes_single_value() ;
		options [ "-write-snp-excl-list" ]
			.set_description( "Don't output a new genotypes file; instead, write files containing the positions of SNPs that are filtered out." )
		;
		options [ "-write-snp-excl-list-file" ]
	        .set_description( 	"Override the auto-generated path(s) of the file to use when outputting the positions of filtered out SNPs.  "
								"(By default, the paths are formed by adding \".snp-excl-list\" to the input gen filename(s).)  "
								"If used, this option must appear as many times as the -g option.  "
	 							"If the corresponding occurence of -g uses a '#' wildcard character, the '#' character can "
								"also be used here to specify numbered output files corresponding to the input files." )
			.set_takes_single_value() ;
		/*
		options [ "-write-snp-incl-list" ]
			.set_description( "Don't output a new genotypes file; instead, write files containing the positions of SNPs that are filtered in." )
			.set_takes_single_value() ;

		options [ "-write-snp-incl-list-file" ]
	        .set_description( 	"Override the auto-generated path(s) of the file to use when outputting the positions of filtered out SNPs.  "
								"(By default, the paths are formed by adding \".snp-excl-list\" to the input gen filename(s).)  "
								"If used, this option must appear as many times as the -g option.  "
	 							"If the corresponding occurence of -g uses a '#' wildcard character, the '#' character can "
								"also be used here to specify numbered output files corresponding to the input files." )
			.set_takes_single_value() ;
		*/

		Relatotron::declare_options( options ) ;
		KinshipCoefficientManager::declare_options( options ) ;
		DataReadTest::declare_options( options ) ;
		ClusterFitter::declare_options( options ) ;
		AssociationTester::declare_options( options ) ;
		VCDBWriter::declare_options( options ) ;
		CallComparerComponent::declare_options( options ) ;
		ClusterPlotter::declare_options( options ) ;
		
		// Other options
		options.declare_group( "Other options" ) ;
		options [ "-force" ] 
			.set_description( "Ignore warnings and proceed with requested action." ) ;
		options [ "-log" ]
			.set_description( "Override the default path of the log file written by " + globals::program_name + "."
				"  By default, this is " + globals::program_name + ".log." )
			.set_takes_single_value()
			.set_default_value( globals::program_name + ".log" ) ;
		options [ "-threads" ]
			.set_description( "Specify the number of worker threads to use in computationally intensive tasks." )
			.set_takes_single_value()
			.set_default_value( 0 ) ;

		options.option_excludes_group( "-snp-stats", "SNP filtering options" ) ;
		options.option_excludes_group( "-sample-stats", "Sample filtering options" ) ;
		options.option_excludes_option( "-sample-stats", "-og" ) ;

		options.option_implies_option( "-write-sample-excl-list-file", "-write-sample-excl-list" ) ;
		options.option_excludes_option( "-write-sample-excl-list", "-os" ) ;
		options.option_excludes_option( "-write-sample-excl-list", "-sample-stats" ) ;

		options.option_implies_option( "-write-snp-excl-list-file", "-write-snp-excl-list" ) ;
		options.option_excludes_option( "-write-snp-excl-list", "-og" ) ;
		options.option_excludes_option( "-write-snp-excl-list", "-snp-stats" ) ;

		options.option_implies_option( "-excl-samples", "-s" ) ;
		options.option_implies_option( "-incl-samples", "-s" ) ;
	}
} ;

struct QCToolOptionMangler {
	QCToolOptionMangler( appcontext::OptionProcessor const& options ):
		m_options( options )
	{
		process_filenames() ;
	}
	std::vector< std::string > const& input_sample_filenames() const { return m_input_sample_filenames ; }
	std::string const& output_sample_filename() const { return m_output_sample_filename ; }
	std::string const& output_sample_excl_list_filename() const { return m_output_sample_excl_list_filename ; }
	std::string const& output_sample_stats_filename() const { return m_sample_statistic_filename ; }
	std::string const log_filename() const { return m_options.get_value< std::string > ( "-log" ) ; }
	InputToOutputFilenameMapper const& gen_filename_mapper() const { return m_gen_file_mapper ; }
	std::vector< std::vector< genfile::wildcard::FilenameMatch > > const& gen_filenames() const { return m_gen_filenames ; } 
	InputToOutputFilenameMapper const& snp_stats_filename_mapper() const { return m_snp_stats_sink_mapper ; }
	InputToOutputFilenameMapper const& snp_excl_list_filename_mapper() const { return m_output_snp_excl_file_mapper ; }
	std::vector< std::string > row_statistics_specs() const {
		// Add default columns
		std::string column_spec = "SNPID, RSID, chromosome, position, minor_allele, major_allele, AA, AB, BB, AA_calls, AB_calls, BB_calls, MAF, HWE, missing, missing_calls, information, " ;
		column_spec += m_options.get_value< std::string >( "-snp-stats-columns" ) ;
		return string_utils::split_and_strip_discarding_empty_entries( column_spec, "," ) ;
	}
	std::vector< std::string > sample_statistics_specs() const {
		std::vector< std::string > result ;
		if( m_options.check_if_option_was_supplied( "-sample-stats" )) {
			result = string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-sample-stats-columns" ), "," ) ;
		}
		return result ;
	}
	
private:
	
	void process_filenames() {
		get_snp_related_filenames() ;
		get_sample_related_filenames() ;
	}

	void get_snp_related_filenames() {
		assert( m_options.check_if_option_was_supplied( "-g" )) ;
		std::vector< std::string > input_gen_filenames_supplied = m_options.get_values< std::string >( "-g" ) ;
		assert( input_gen_filenames_supplied.size() >= 1 ) ;
		std::string
			output_gen_filename = construct_output_gen_filename( input_gen_filenames_supplied ),
			output_snp_stats_filename = construct_snp_stats_filename( input_gen_filenames_supplied ),
			output_snp_excl_filename = construct_output_snp_excl_list_filename( input_gen_filenames_supplied ) ;

		m_gen_file_mapper.add_filename_pair( input_gen_filenames_supplied[0], output_gen_filename ) ;
		m_snp_stats_sink_mapper.add_filename_pair( input_gen_filenames_supplied[0], output_snp_stats_filename ) ;
		m_output_snp_excl_file_mapper.add_filename_pair( input_gen_filenames_supplied[0], output_snp_excl_filename ) ;

		m_gen_filenames.resize( input_gen_filenames_supplied.size() ) ;
		for( std::size_t i = 0; i < input_gen_filenames_supplied.size(); ++i ) {
			m_gen_filenames[i] = genfile::wildcard::find_files_by_chromosome(
				input_gen_filenames_supplied[i],
				genfile::wildcard::eALL_CHROMOSOMES
			) ;
		}
	}

	void get_sample_related_filenames() {
		if( m_options.check_if_option_was_supplied( "-s" ) ) {
			m_input_sample_filenames = m_options.get_values< std::string >( "-s" ) ;
			assert( m_input_sample_filenames.size() == m_gen_filenames.size() ) ;
		}

		// We need to write a sample stats file if -sample-stats was given.
		if( m_options.check_if_option_was_supplied( "-sample-stats" ) ) {
			if( m_options.check_if_option_was_supplied( "-sample-stats-file" )) {
				m_sample_statistic_filename = m_options.get_value< std::string >( "-sample-stats-file" ) ;
			}
			else {
				std::string stub ;
				if( m_input_sample_filenames.size() > 0 ) {
					stub = strip_sample_file_extension_if_present( m_input_sample_filenames[0] ) ;
				}
				else {
					stub = "qctool" ;
				}

				m_sample_statistic_filename = stub + ".sample-stats";
			}
		}
		// Otherwise, we need to write a sample exclusion list file if -write-sample-excl-list was given.
		else if( m_options.check_if_option_was_supplied( "-write-sample-excl-list" )) {
			if( m_options.check_if_option_was_supplied( "-write-sample-excl-list-file" )) {
				m_output_sample_excl_list_filename = m_options.get_value< std::string > ( "-write-sample-excl-list-file" ) ;
			}
			else {
				if( m_input_sample_filenames.size() > 0 ) {
					m_output_sample_excl_list_filename = strip_sample_file_extension_if_present( m_input_sample_filenames[0] ) + ".sample-excl-list" ;
				}
				else {
					m_output_sample_excl_list_filename = "qctool.sample-excl-list" ;
				}
			}
		}

		// We need to write a sample file if:
		// -os is given
		// OR
		// -write-sample-excl-list is NOT given
		// AND EITHER
		//	 * -sample-stats is given,
		//   * OR some sample filters are given
		if( m_options.check_if_option_was_supplied( "-os" )) {
			m_output_sample_filename = m_options.get_value< std::string >( "-os" ) ;
		}
		else if( !m_options.check_if_option_was_supplied( "-write-sample-excl-list" )
			&& (
				m_options.check_if_option_was_supplied( "-sample-stats" ) ||
				m_options.check_if_option_was_supplied_in_group( "Sample filtering options" )
			)
		) {
			std::string stub ;
			if( m_input_sample_filenames.size() > 0 ) {
				stub = strip_sample_file_extension_if_present( m_input_sample_filenames[0] ) ;
			}
			else {
				stub = "qctool" ;
			}

			if( m_options.check_if_option_was_supplied_in_group( "Sample filtering options" ) ) {
				m_output_sample_filename = stub + ".fltrd.sample";
			}
			else {
				m_output_sample_filename = stub + ".qctool.sample" ;
			}
		}
	}

	std::string strip_sample_file_extension_if_present( std::string filename ) {
		if( filename.size() >= 7 && filename.substr( filename.size() - 7, 7 ) == ".sample" ) {
			filename.resize( filename.size() - 7 ) ;
		}
		return filename ;
	}

	std::string construct_output_gen_filename( std::vector< std::string > const& input_gen_filenames_supplied ) {
		std::string result ;
		// We need to produce output gen files if
		//  * -og is given
		//  OR
		//  ** -write-snp-excl-list is not set
		//  * AND EITHER
		//  ** some sample filters are given (but not -write-sample-excl-list)
		//  ** OR some SNP filters are given.
		if( m_options.check_if_option_was_supplied( "-og" )
			|| (
				!( m_options.check_if_option_was_supplied( "-write-snp-excl-list" ) || m_options.check_if_option_was_supplied( "-write-snp-incl-list" ) )
				&& (
					(m_options.check_if_option_was_supplied_in_group( "Sample filtering options" ) && !m_options.check_if_option_was_supplied( "-write-sample-excl-list" ))
					||
					m_options.check_if_option_was_supplied_in_group( "SNP filtering options" )
				)
			)
		) {
			if( m_options.check_if_option_was_supplied( "-og" ) ) {
				result = m_options.get_value< std::string >( "-og" ) ;
			} else {
				assert( input_gen_filenames_supplied.size() > 0 ) ;
				std::string stub ;
				if( input_gen_filenames_supplied.size() == 1 )  {
					stub = input_gen_filenames_supplied[0] ;
				}
				else {
					stub = "qctool_cohorts_1-" + string_utils::to_string( input_gen_filenames_supplied.size() ) ;
				}
				result
					= genfile::strip_gen_file_extension_if_present( stub )
					+ ".fltrd"
					+ genfile::get_gen_file_extension_if_present( input_gen_filenames_supplied[0] ) ;
			}
		}
		return result ;
	}

	std::string construct_snp_stats_filename( std::vector< std::string > const& input_gen_filenames_supplied ) {
		std::string result ;
		if( m_options.check_if_option_was_supplied( "-snp-stats" ) ) {
			if( m_options.check_if_option_was_supplied( "-snp-stats-file" )) {
				result = m_options.get_value< std::string >( "-snp-stats-file" ) ;
			}
			else {
				assert( input_gen_filenames_supplied.size() > 0 ) ;
				std::string stub ;
				if( input_gen_filenames_supplied.size() == 1 ) {
					stub = input_gen_filenames_supplied[0] ;
				}
				else {
					stub = "qctool_cohorts_1-" + string_utils::to_string( input_gen_filenames_supplied.size() ) ;
				}
				result = genfile::strip_gen_file_extension_if_present( stub ) + ".snp-stats" ;
			}
		}
		return result ;
	}

	std::string construct_output_snp_excl_list_filename( std::vector< std::string > const& input_gen_filenames_supplied ) {
		std::string result ;
		if( m_options.check_if_option_was_supplied( "-write-snp-excl-list" ) ) {
			if( m_options.check_if_option_was_supplied( "-write-snp-excl-list-file" )) {
				result = m_options.get_value< std::string >( "-write-snp-excl-list-file" ) ;
			}
			else {
				assert( input_gen_filenames_supplied.size() > 0 ) ;
				std::string stub ;
				if( input_gen_filenames_supplied.size() == 1 ) {
					stub = input_gen_filenames_supplied[0] ;
				}
				else {
					stub = "qctool_cohorts_1-" + string_utils::to_string( input_gen_filenames_supplied.size() ) ;
				}
				result = genfile::strip_gen_file_extension_if_present( stub ) + ".snp-excl-list" ;
			}
		}
		return result ;
	}

private:
	appcontext::OptionProcessor const& m_options ;
	std::vector< std::string > m_input_sample_filenames ;
	std::string m_output_sample_filename ;
	std::string m_output_sample_excl_list_filename ; 
	std::string m_sample_statistic_filename ;
	std::string m_log_filename ;
	InputToOutputFilenameMapper m_gen_file_mapper ;
	InputToOutputFilenameMapper m_snp_stats_sink_mapper ;
	InputToOutputFilenameMapper m_output_snp_excl_file_mapper ;
	std::vector< std::vector< genfile::wildcard::FilenameMatch > > m_gen_filenames ;
} ;


struct QCToolCmdLineContext: public QCToolContext
{
	QCToolCmdLineContext( appcontext::OptionProcessor const& options, appcontext::UIContext& ui_context ):
		m_options( options ),
		m_mangled_options( options ),
		m_ui_context( ui_context )
	{
		try {
			setup() ;
		}
		catch( genfile::MalformedInputError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() <<"): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileContainsSNPsOfDifferentSizes const& ) {
			m_ui_context.logger() << "\nError: The GEN files specified did not all have the same sample size.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileNotFoundError const& e ) {
			m_ui_context.logger() << "\nError: No file matching \"" << e.filespec() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::ResourceNotOpenedError const& e ) {
			m_ui_context.logger() << "\nError: (" << e.what() << "): resource \"" << e.source() << "\" could not be opened.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch ( FileError const& e ) {
			m_ui_context.logger() << "\nFile handling exception: " << e.what() << ": relating to file \"" << e.filename() << "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch ( genfile::KeyNotFoundError const& e ) {
			m_ui_context.logger() << "\nKey \"" << e.key() << "\" was not found in source \"" << e.source() << "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch ( genfile::DuplicateKeyError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() << "): Duplicate key \"" << e.key() << "\" was found in source \"" << e.source() << "\".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( statfile::FileNotOpenedError const& e ) {
			m_ui_context.logger() << "\nError: No file matching \"" << e.filename() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::OperationFailedError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() << "): " << e.caller() << ": error attempting to perform the following operation on " << e.object()<< ":\n"
				<< e.operation() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::OperationUnsupportedError const& e ) {
			m_ui_context.logger() << "\nError (" << e.what() << "): " << ": the following operation on " << e.object()<< " is not supported:\n"
				<< e.operation() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	~QCToolCmdLineContext() {
		write_postamble() ;
		// Ensure a fixed deconstruction order so that samples and pedigree outlive
		// the SNP Data Sinks.
		m_fltrd_out_snp_data_sink.reset() ;
		m_fltrd_in_snp_data_sink.reset() ;
		m_cohort_individual_source.reset() ;
		m_pedigree.reset() ;
	}
	
	SNPDataSource& snp_data_source() const {
		return *m_snp_data_source ;
	}

	SNPDataSink& fltrd_in_snp_data_sink() const {
		return *m_fltrd_in_snp_data_sink ;
	}
	
	SNPDataSink& fltrd_out_snp_data_sink() const {
		return *m_fltrd_out_snp_data_sink ;
	}
	
	std::vector< SampleRow >& sample_rows() {
		return m_sample_rows ;
	}

	ObjectSink< SampleRow >& fltrd_in_sample_sink() const {
		return *m_fltrd_in_sample_sink ;
	}

	ObjectSink< SampleRow >& fltrd_out_sample_sink() const {
		return *m_fltrd_out_sample_sink ;
	}

	statfile::BuiltInTypeStatSink& snp_stats_sink() const {
		assert( m_snp_stats_sink.get() ) ;
		return *m_snp_stats_sink ;
	}

	statfile::BuiltInTypeStatSink& sample_stats_sink() const {
		assert( m_sample_stats_sink.get() ) ;
		return *m_sample_stats_sink ;
	}
	
	AndRowCondition& snp_filter() const {
		return *m_snp_filter ;
	}
	
	AndRowCondition& sample_filter() const {
		return *m_sample_filter ;
	}
	
	GenRowStatistics& snp_statistics() {
		return m_snp_statistics ;
	}

	SampleRowStatistics& sample_statistics() {
		return m_sample_statistics ;
	}
	
	std::vector< std::size_t > const& indices_of_filtered_out_samples() const { return m_indices_of_filtered_out_samples ; }
	
	bool ignore_warnings() const {
		return m_ignore_warnings ;
	}

	std::vector< std::size_t >& snp_filter_failure_counts() { return m_snp_filter_failure_counts ; }
	std::vector< std::size_t >& sample_filter_failure_counts() { return m_sample_filter_failure_counts ; }

	void write_preamble() {
		m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;

		m_ui_context.logger() << std::setw(30) << "Input SAMPLE file(s):" ;
		for( std::size_t i = 0; i < m_mangled_options.input_sample_filenames().size(); ++i ) {
			if( i > 0 ) {
				m_ui_context.logger() << std::setw(30) << "" ;
			}
			m_ui_context.logger() << "  \"" << format_filename( m_mangled_options.input_sample_filenames()[i]) << "\"\n" ;
		}
		
		if(
			genfile::ValueMappingCohortIndividualSource const* source
				= dynamic_cast< genfile::ValueMappingCohortIndividualSource const* >( m_cohort_individual_source.get() )
		) {
			m_ui_context.logger() << std::setw(30) << "Sample file summary:" << "  " ;
			m_ui_context.logger() << source->get_summary( std::string( 32, ' ' )) << "\n" ;
		}
		
		m_ui_context.logger() << std::setw(30) << "Output SAMPLE file:"
			<< "  \"" << format_filename( m_mangled_options.output_sample_filename()) << "\".\n" ;
		m_ui_context.logger() << std::setw(30) << "Sample statistic output file:"
			<< "  \"" << format_filename( m_mangled_options.output_sample_stats_filename()) << "\".\n" ;
		m_ui_context.logger() << std::setw(30) << "Sample exclusion output file:"
			<< "  \"" << format_filename( m_mangled_options.output_sample_excl_list_filename()) << "\".\n" ;
		m_ui_context.logger() << "\n" ;

		m_ui_context.logger() << std::setw(30) << "Input GEN file(s):\n" ;
		m_ui_context.logger()<< m_snp_data_source->get_summary( "", 40 ) ;
		if( m_mangled_options.gen_filename_mapper().input_files().size() > 1 ) {
			m_ui_context.logger() << "\n" ;
		}

		m_ui_context.logger() << std::setw(30) << "Output GEN file(s):" ;
		if( m_mangled_options.gen_filename_mapper().output_filenames().empty() ) {
			m_ui_context.logger() << "  (n/a)\n" ;
		}
		else {
			for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << "\n" << std::string( 30, ' ' ) ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.gen_filename_mapper().output_filenames()[i] << "\"" ;				
			}
			m_ui_context.logger() << "\n" ;
		}

		m_ui_context.logger() << std::setw(30) << "Output SNP position file(s):" ;
		if( m_mangled_options.snp_excl_list_filename_mapper().output_filenames().empty() ) {
			m_ui_context.logger() << "  (n/a)\n" ;
		}
		else {
			for( std::size_t i = 0; i < m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << "\n" << std::string( 30, ' ' ) ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.snp_excl_list_filename_mapper().output_filenames()[i] << "\"" ;				
			}
			m_ui_context.logger() << "\n" ;
		}

		m_ui_context.logger() << std::setw(30) << "SNP statistic output file(s):" ;
		for( std::size_t i = 0; i < m_mangled_options.snp_stats_filename_mapper().output_filenames().size(); ++i ) {
			if( i > 0 ) {
				m_ui_context.logger() << std::string( 30, ' ' ) ;
			}
			m_ui_context.logger() << "  \"" << m_mangled_options.snp_stats_filename_mapper().output_filenames()[i] << "\"\n" ;
		}
		m_ui_context.logger() << "\n" ;
		m_ui_context.logger() << std::setw(30) << "Sample filter:" 
			<< "  " << *m_sample_filter << ".\n" ;
		m_ui_context.logger() << std::setw(30) << "SNP filter:"
			<< "  " << *m_snp_filter << ".\n" ;
		m_ui_context.logger() << "\n" ;

		m_ui_context.logger() << std::setw(30) << "# of samples in input files:"
			<< "  " << m_snp_data_source->get_base_source().number_of_samples() << ".\n" ;
		m_ui_context.logger() << std::setw(30) << "# of samples after filtering:"
			<< "  " << m_snp_data_source->number_of_samples()
			<< " (" << m_indices_of_filtered_out_samples.size()
			<< " filtered out).\n" ;

		m_ui_context.logger() << "\n" << std::string( 72, '=' ) << "\n\n" ;

		if( !m_errors.empty() ) {
			for( std::size_t i = 0; i < m_errors.size(); ++i ) {
				m_ui_context.logger() << "!! ERROR: " << m_errors[i] << "\n\n" ;
			}
			m_ui_context.logger() << "!! Please correct the above errors and re-run qctool.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}

		if( !m_warnings.empty() ) {
			for( std::size_t i = 0; i < m_warnings.size(); ++i ) {
				m_ui_context.logger() << "!! WARNING: " << m_warnings[i] << "\n\n" ;
			}
			if( m_ignore_warnings ) {
				m_ui_context.logger() << "!! Warnings were encountered, but proceeding anyway as -force was supplied.\n" ;
				m_ui_context.logger() << "\n" << std::string( 72, '=' ) << "\n\n" ;
			}
			else {
				m_ui_context.logger() << "!! Warnings were encountered.  To proceed anyway, please run again with the -force option.\n" ;
				throw appcontext::HaltProgramWithReturnCode( -1 ) ;
			}
		}
		
	}
	
	std::string format_filename( std::string const& filename ) {
		if( filename == "" ) {
			return "(n/a)" ;
		}
		else {
			return filename ;
		}
	}
	
	void write_postamble() {
		m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;
		if( m_backup_creator.backed_up_files().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "I took backups of the following files before overwriting:\n" ;
			std::size_t max_length = 0u ;
			for(
				std::map< std::string, std::string >::const_iterator i = m_backup_creator.backed_up_files().begin() ;
				i != m_backup_creator.backed_up_files().end() ;
				++i
			) {
				max_length = std::max( max_length, i->first.size() ) ;
			}

			for(
				std::map< std::string, std::string >::const_iterator i = m_backup_creator.backed_up_files().begin() ;
				i != m_backup_creator.backed_up_files().end() ;
				++i
			) {
				m_ui_context.logger() << "  " << std::setw( max_length + 2 ) << std::left << ("\"" + i->first + "\"") << " to \"" << i->second << "\"\n" ;
			}

			m_ui_context.logger() << "\n" ;
			m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;
		}

		m_ui_context.logger() << std::setw(36) << "Number of SNPs in input file(s):"
			<< "  " << m_snp_data_source->total_number_of_snps() << ".\n" ;
		if( m_snp_filter->number_of_subconditions() > 0 ) {
			for( std::size_t i = 0; i < m_snp_filter->number_of_subconditions(); ++i ) {
				m_ui_context.logger() << std::setw(36) << ("...which failed \"" + string_utils::to_string( m_snp_filter->subcondition( i )) + "\":")
					<< "  " << m_snp_filter_failure_counts[i] << ".\n" ;
			}

			m_ui_context.logger() << std::setw(36) << "(total failures:"
				<< "  " << m_fltrd_out_snp_data_sink->number_of_snps_written() << ").\n" ;
		}
		
		m_ui_context.logger() << "\n" ;

		m_ui_context.logger() << std::setw(36) << "Number of samples in input file(s):"
			<< "  " << m_snp_data_source->number_of_samples() << ".\n" ;
		if( m_sample_filter->number_of_subconditions() > 0 ) {
			for( std::size_t i = 0 ; i < m_sample_filter_failure_counts.size(); ++ i ) {
				m_ui_context.logger() << std::setw(36) << ("...which failed \"" + string_utils::to_string( m_sample_filter->subcondition( i )) + "\":")
					<< "  " << m_sample_filter_failure_counts[i] << ".\n" ;
			}
			m_ui_context.logger() << std::setw(36) << "(total failures:" << "  " << m_indices_of_filtered_out_samples.size() << ").\n" ;
		}

		m_ui_context.logger() << "\n" ;

		if( m_mangled_options.output_sample_excl_list_filename() != "" ) {
			m_ui_context.logger() << std::setw(36) << "Output sample exclusion list:"
				<< " " << m_mangled_options.output_sample_excl_list_filename() << " ("
				<< m_indices_of_filtered_out_samples.size() << " samples).\n" ;
		}

		if( m_mangled_options.gen_filename_mapper().output_filenames().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "Output GEN files:" ;
			for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << std::string( 36, ' ' ) ;
				}
				if( m_fltrd_in_snp_data_sink.get() ) {
					m_ui_context.logger() << "  (" << std::setw(6) << m_fltrd_in_snp_data_sink->sink(i).number_of_snps_written() << " snps)  " ;
				}
				m_ui_context.logger() << "\"" << m_mangled_options.gen_filename_mapper().output_filenames()[i] << "\"\n" ;
			}
			m_ui_context.logger() << std::string( 36, ' ' ) << "  (total " << m_fltrd_in_snp_data_sink->number_of_snps_written() << " snps).\n" ;
		}
		
		if( m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "Output SNP exclusion list(s):" ;
			for( std::size_t i = 0; i < m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << std::string( 36, ' ' ) ;
				}
				if( m_fltrd_out_snp_data_sink.get() ) {
					m_ui_context.logger() << "  (" << std::setw(6) << m_fltrd_out_snp_data_sink->sink(i).number_of_snps_written() << " snps)  " ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.snp_excl_list_filename_mapper().output_filenames()[i] << "\"\n" ;				
			}
			m_ui_context.logger() << std::string( 36, ' ' ) << "  (total " << m_fltrd_out_snp_data_sink->number_of_snps_written() << " snps).\n" ;
		}
		
		if( m_mangled_options.output_sample_filename() != "" ) {
			m_ui_context.logger() << std::setw(36) << "Output SAMPLE files:"
				<< "  \"" << m_mangled_options.output_sample_filename() << "\""
				<< "  (" << m_sample_rows.size() << " samples)\n" ;
		}
		if( m_mangled_options.snp_stats_filename_mapper().output_filenames().size() > 0 ) {
			m_ui_context.logger() << std::setw(36) << "SNP statistic output file(s):" ;
			for( std::size_t i = 0; i < m_mangled_options.snp_stats_filename_mapper().output_filenames().size(); ++i ) {
				if( i > 0 ) {
					m_ui_context.logger() << std::string( 36, ' ' ) ;
				}
				m_ui_context.logger() << "  \"" << m_mangled_options.snp_stats_filename_mapper().output_filenames()[i] << "\"\n" ;
			}
		}
		if( m_mangled_options.output_sample_stats_filename() != "" ) {
			m_ui_context.logger() << std::setw(36) << "Sample statistic output file:"
				<< "  \"" << m_mangled_options.output_sample_stats_filename() << "\".\n" ;
		}

		m_ui_context.logger()[ "screen" ] << std::setw( 36 ) << "\nMore details are in the log file:"
			<< "  \"" << m_mangled_options.log_filename() << "\".\n" ;
		m_ui_context.logger() << std::string( 72, '=' ) << "\n\n" ;
	}

	genfile::CohortIndividualSource const& get_cohort_individual_source() const { assert( m_cohort_individual_source.get() ) ; return *m_cohort_individual_source ; }

private:
	appcontext::OptionProcessor const& m_options ;
	QCToolOptionMangler const m_mangled_options ;
	appcontext::UIContext& m_ui_context ;

	typedef std::map< genfile::SNPIdentifyingData, genfile::SNPIdentifyingData > SNPDictionary ;
	std::auto_ptr< SNPDictionary > m_snp_dictionary ;

	typedef std::map< genfile::SNPIdentifyingData, char > StrandSpec ;
	typedef std::vector< StrandSpec > StrandSpecs ;
	std::auto_ptr< StrandSpecs > m_strand_specs ;
	genfile::Pedigree::UniquePtr m_pedigree ;	// this must go before snp_data_sinks.
	genfile::CohortIndividualSource::UniquePtr m_cohort_individual_source ; // this must go before the snp_data_sinks.
	std::auto_ptr< genfile::SNPDataSource > m_snp_data_source ;
	std::auto_ptr< genfile::SNPDataSinkChain > m_fltrd_in_snp_data_sink ;
	std::auto_ptr< genfile::SNPDataSinkChain > m_fltrd_out_snp_data_sink ;
	std::auto_ptr< ObjectSource< SampleRow > > m_sample_source ;

	std::vector< SampleRow > m_sample_rows ;

	std::auto_ptr< ObjectSink< SampleRow > > m_fltrd_in_sample_sink ;
	std::auto_ptr< ObjectSink< SampleRow > > m_fltrd_out_sample_sink ;
	std::auto_ptr< statfile::BuiltInTypeStatSink > m_snp_stats_sink ;
	std::auto_ptr< statfile::BuiltInTypeStatSink > m_sample_stats_sink ;

	std::vector< std::size_t > m_snp_filter_failure_counts ;
	std::vector< std::size_t > m_sample_filter_failure_counts ;
	
	bool m_ignore_warnings ; 
	
	std::size_t m_current_snp_stats_filename_index ;

	std::auto_ptr< AndRowCondition > m_snp_filter ;
	std::auto_ptr< AndRowCondition > m_sample_filter ;

	GenRowStatistics m_snp_statistics ;
	SampleRowStatistics m_sample_statistics ;
	
	std::vector< std::size_t > m_indices_of_filtered_out_samples ;
	
	ToNumberedFileBackupCreator m_backup_creator ;
	
	std::vector< std::string > m_warnings ;
	std::vector< std::string > m_errors ;
	
private:
	
	void setup() {
			construct_snp_statistics() ;
			construct_sample_statistics() ;
			construct_snp_filter() ;
			construct_sample_filter() ;
			process_other_options() ;
			
			if( m_options.check_if_option_has_value( "-translate-snp-positions" )) {
				m_snp_dictionary = load_snp_dictionary( m_options.get_value< std::string >( "-translate-snp-positions" ) ) ;
			}

			if( m_options.check_if_option_has_value( "-strand" )) {
				m_strand_specs = get_strand_specs( m_options.get_values< std::string >( "-strand" )) ;
			}
			
			m_snp_data_source = open_snp_data_sources() ;
			
			m_cohort_individual_source = load_sample_rows( m_snp_data_source->number_of_samples() ) ;
			
			check_for_errors_and_warnings() ;
				
			if( m_indices_of_filtered_out_samples.size() > 0 ) {
				m_snp_data_source.reset(
					new genfile::SampleFilteringSNPDataSource(
						m_snp_data_source,
						std::set< std::size_t >( m_indices_of_filtered_out_samples.begin(), m_indices_of_filtered_out_samples.end() )
					)
				) ;
				
				if( m_cohort_individual_source.get() ) {
					m_cohort_individual_source.reset(
						genfile::SampleFilteringCohortIndividualSource::create(
							m_cohort_individual_source,
							std::set< std::size_t >( m_indices_of_filtered_out_samples.begin(), m_indices_of_filtered_out_samples.end() )
						).release()
					) ;
				}
			}

			write_preamble() ;
			
			open_sample_row_sink() ;
			open_snp_data_sinks() ;
			open_snp_stats_sink( 0, m_snp_statistics ) ;
			open_sample_stats_sink() ;
	}
	
	std::auto_ptr< StrandSpecs > get_strand_specs( std::vector< std::string > const& filenames ) const {
		std::auto_ptr< StrandSpecs > result( new StrandSpecs( filenames.size() ) ) ;
		
		appcontext::UIContext::ProgressContext progress_context = m_ui_context.get_progress_context( "Loading strand files" ) ;
		progress_context.notify_progress( 0, filenames.size() ) ;
		
		std::vector< std::pair< int, int > > summaries( filenames.size(), std::make_pair( 0, 0 ) ) ; // first = row count, second = failure count.
		
		for( std::size_t i = 0; i < filenames.size(); ++i ) {
			statfile::BuiltInTypeStatSource::UniquePtr source( statfile::BuiltInTypeStatSource::open( filenames[i] )) ;
			if( source->number_of_columns() < 6 ) {
				throw genfile::MalformedInputError( filenames[i], 1 ) ;
			}

			std::string platform_column_names ;
			if( source->has_column( "Affy SNP ID" )) {
				platform_column_names = "Chromosome|Physical Position|Probe Set ID|dbSNP RS ID|Allele A|Allele B|Strand" ;
			}
			else if( source->has_column( "IlmnID" )) {
				platform_column_names = "Chromosome|position|IlmnID|rsid|alleleA|alleleB|strand" ;
			}
			else if( source->has_column( "SNPID" ) ) {
				platform_column_names = "chromosome|position|SNPID|rsid|alleleA|alleleB|strand" ;
			}
			else {
				throw genfile::MalformedInputError( source->get_source_spec(), 0 ) ;
			}

			summaries[i].first = source->number_of_rows() ; // row count.

			while( *source ) {
				genfile::SNPIdentifyingData snp ;
				std::string strand ;
				try {
					if(
						statfile::read_values(
							*source,
							platform_column_names,
							boost::tie(
								snp.position().chromosome(),
								snp.position().position(),
								snp.SNPID(),
								snp.rsid(),
								snp.first_allele(),
								snp.second_allele(),
								strand
							)
						)
					) {
						// Support illumina "FWD" and "REV" strands.
						if( strand == "REV" || strand == "-" ) {
							strand = genfile::StrandAligningSNPDataSource::eReverseStrand ;
						}
						else if( strand == "FWD" || strand == "+" ) {
							strand = genfile::StrandAligningSNPDataSource::eForwardStrand ;
						}
						else if( strand == "?" || strand == "NA" ) {
							// std::cerr << "strand = ?: SNP is " << snp << ".\n" ;
							strand = genfile::StrandAligningSNPDataSource::eUnknownStrand ;
						}
						else {
							m_ui_context.logger() << "!! Error: found unrecognised strand \"" << strand << "\" in strand alignment file.\n" ;
							throw genfile::MalformedInputError( source->get_source_spec(), source->number_of_rows_read() + 1 ) ;
						}
				
						StrandSpec::iterator where = result->at(i).find( snp ) ;
						if( where != result->at(i).end() ) {
							throw genfile::DuplicateKeyError( source->get_source_spec(), genfile::string_utils::to_string( snp ) ) ;
						}
						result->at(i)[ snp ] = strand[0] ;
						(*source) >> statfile::ignore_all() ;
					}
				}
				catch( genfile::InputError ) {
					++summaries[i].second ; // failure count
					(*source) >> statfile::ignore_all() ;
				}
			}
			assert( source->number_of_rows_read() == source->number_of_rows() ) ;

			progress_context.notify_progress( i+1, filenames.size() ) ;
		}
		
		m_ui_context.logger() << "\nStrand file summary:\n" ;
		for( std::size_t i = 0; i < summaries.size(); ++i ) {
			m_ui_context.logger() << std::setw( 30) << ( "  \"" + filenames[i] + "\"" ) << ": " << std::setw( 7 ) << summaries[i].first << " rows" ;
			if( summaries[i].second > 0 ) {
				m_ui_context.logger() << " of which " << summaries[i].second << " may be malformed, and will be ignored" ;
			}
			m_ui_context.logger() << ".\n" ;
		}
		
		return result ;
	}
	
	genfile::SNPDataSource::UniquePtr open_snp_data_sources()
	// Open the gen files, taking care of filtering, strand alignment, translation, etc.
	{
		// Kludge: this optimisation ensures that a vcf file, which can be huge,
		// can be opened relatively quickly.  It will be especially fast
		// if it has a ##number-of-variants=N line in the metadata.  Before doing this we check
		// that there is only one file, that no strand alignment or SNP exclusions or
		// snp translation are necessary.
		if(
			( m_mangled_options.gen_filenames().size() == 1 && m_mangled_options.gen_filenames()[0].size() == 1 )
			&& !m_strand_specs.get()
			&& !get_snp_exclusion_filter().get()
			&& !m_snp_dictionary.get() 
		) {
			std::string filename = m_mangled_options.gen_filenames()[0][0].filename() ;
			std::pair< std::string, std::string > uf = genfile::uniformise( filename ) ;
			if( uf.first == "vcf" ) {
				return open_vcf_format_snp_data_source( uf ) ;
			}
		}
	
		genfile::SNPDataSourceRack::UniquePtr rack(
			new genfile::SNPDataSourceRack( m_options.get_value< std::string >( "-snp-match-fields" ) )
		) ;

		// count files.
		std::size_t file_count = 0 ;
		for( std::size_t i = 0; i < m_mangled_options.gen_filenames().size(); ++i ) {
			file_count += m_mangled_options.gen_filenames()[i].size() ;
		}

		appcontext::UIContext::ProgressContext progress_context = m_ui_context.get_progress_context( "Opening genotype files" ) ;
		progress_context.notify_progress( 0, file_count ) ;

		std::size_t progress_count = 0 ;

		for( std::size_t i = 0; i < m_mangled_options.gen_filenames().size(); ++i ) {
			genfile::SNPDataSourceChain::UniquePtr chain( new genfile::SNPDataSourceChain() ) ;
			std::vector< genfile::SNPIdentifyingData > snps ;

			for( std::size_t j = 0; j < m_mangled_options.gen_filenames()[i].size(); ++j ) {
				std::pair< genfile::SNPDataSource*, std::vector< genfile::SNPIdentifyingData > > source = open_snp_data_source(
					m_mangled_options.gen_filenames()[i][j].filename(),
					m_mangled_options.gen_filenames()[i][j].match()
				) ;

				// Add the source to the chain.
				chain->add_source( genfile::SNPDataSource::UniquePtr( source.first ) ) ;
				// Add the source's SNPs to our list.
				snps.insert( snps.end(), source.second.begin(), source.second.end() ) ;

				progress_context.notify_progress( ++progress_count, file_count ) ;
			}

			// sanity check.
			assert( snps.size() == chain->total_number_of_snps() ) ;

			if( i == 0 ) {
				// set up the trigger by which we move through output files.
				chain->set_moved_to_next_source_callback( boost::bind( &QCToolCmdLineContext::move_to_next_output_file, this, _1 )) ;
			}
			
			genfile::SNPDataSource::UniquePtr source( chain.release() ) ;
			
			// If we have strand alignment information, implement it now
			if( m_strand_specs.get() ) {
				assert( m_strand_specs->size() == m_mangled_options.gen_filenames().size() ) ;
				genfile::StrandAligningSNPDataSource::StrandAlignments strand_alignments ;
				boost::tie( snps, strand_alignments ) = genfile::StrandAligningSNPDataSource::create_strand_alignments(
					snps,
					m_strand_specs->at(i)
				) ;
				source.reset(
					genfile::StrandAligningSNPDataSource::create(
						source,
						strand_alignments
					)
					.release()
				) ;
			}

			if( m_options.check_if_option_was_supplied( "-match-alleles-to-cohort1" ) && i > 0 ) {
				genfile::AlleleFlippingSNPDataSource::AlleleFlipSpec allele_flip_spec ;
				boost::tie( snps, allele_flip_spec ) = genfile::AlleleFlippingSNPDataSource::get_allele_flip_spec(
					rack->get_snps(),
					snps,
					genfile::SNPIdentifyingData::CompareFields(
						m_options.get_value< std::string >( "-snp-match-fields" ) + ",alleles"
					)
				) ;
				
				source.reset(
					genfile::AlleleFlippingSNPDataSource::create(
						source,
						allele_flip_spec
					)
					.release()
				) ;
			}
			
			rack->add_source(
				source,
				snps
			) ;
		}
		return genfile::SNPDataSource::UniquePtr( rack.release() ) ;		
	}
	
	std::pair< genfile::SNPDataSource*, std::vector< genfile::SNPIdentifyingData > >
	open_snp_data_source( std::string const& filename, std::string chromosome_indicator ) const {
		if( chromosome_indicator == "" && m_options.check_if_option_was_supplied( "-assume-chromosome" )) {
			chromosome_indicator = m_options.get_value< std::string >( "-assume-chromosome" ) ;
		}

		genfile::SNPDataSource::UniquePtr source ;

		std::pair< std::string, std::string > uf = genfile::uniformise( filename ) ;

		if( uf.first == "vcf" ) {
			source = open_vcf_format_snp_data_source( uf ) ;
		}
		else {
			genfile::vcf::MetadataParser::Metadata metadata ;
			if( m_options.check( "-metadata" )) {
				metadata = genfile::vcf::StrictMetadataParser(
					m_options.get_value< std::string >( "-metadata" )
				).get_metadata() ;
			}
			source = genfile::SNPDataSource::create(
				filename,
				chromosome_indicator,
				metadata
			) ;
		}
		
		std::vector< genfile::SNPIdentifyingData > snps = genfile::get_list_of_snps_in_source( *source ) ;
		source->reset_to_start() ;
		
		// Filter SNPs if necessary
		genfile::CommonSNPFilter::UniquePtr snp_filter = get_snp_exclusion_filter() ;
		if( snp_filter.get() ) {
			std::vector< std::size_t > indices_of_filtered_in_snps = snp_filter->get_indices_of_filtered_in_snps( snps ) ;
			source.reset(
				genfile::SNPFilteringSNPDataSource::create(
					source,
					indices_of_filtered_in_snps
				).release()
			) ;
			
			// Keep track of the SNPs in the source by hand.
			// This prevents an extra scan through the file, which can be slow.
			snps = genfile::utility::select_entries( snps, indices_of_filtered_in_snps ) ;
		}
		
		// Translate SNP identifying data if necessary
		if( m_snp_dictionary.get() ) {
			source.reset(
				genfile::SNPTranslatingSNPDataSource::create(
					source,
					*m_snp_dictionary
				).release()
			) ;
			
			// Keep track of the SNPs in the source by hand.
			// This prevents an extra scan through the file, which can be slow.
			for( std::size_t i = 0; i < snps.size(); ++i ) {
				std::map< genfile::SNPIdentifyingData, genfile::SNPIdentifyingData >::const_iterator where = m_snp_dictionary->find( snps[i] ) ;
				if( where != m_snp_dictionary->end() ) {
					snps[i] = where->second ;
				}
			}
		}

		return std::make_pair(
			source.release(),
			snps
		) ;
	}
	
	genfile::SNPDataSource::UniquePtr
	open_vcf_format_snp_data_source( std::pair< std::string, std::string > const& uf ) const {
		genfile::VCFFormatSNPDataSource::UniquePtr source ;
		if( m_options.check_if_option_was_supplied( "-metadata" )) {
			source.reset(
				new genfile::VCFFormatSNPDataSource(
					uf.second,
					genfile::vcf::StrictMetadataParser(
						m_options.get_value< std::string >( "-metadata" )
					).get_metadata()
				)
			) ;
		}
		else {
			source.reset(
				new genfile::VCFFormatSNPDataSource(
					uf.second
				)
			) ;
		}
		
		std::vector< std::string > fields = genfile::string_utils::split_and_strip(
			m_options.get_value< std::string >( "-vcf-field-map" ),
			","
			" \t"
		) ;
		
		for( std::size_t i = 0; i < fields.size(); ++i ) {
			std::vector< std::string > key_value = genfile::string_utils::split_and_strip( fields[i], ":", " \t" ) ;
			if( key_value.size() != 2 ) {
				throw genfile::BadArgumentError(
					"QCToolCmdLineContext::open_vcf_format_snp_data_source()", "vcf field map \"" + fields[i] + "\"."
				) ;
			}
			source->set_field_mapping( key_value[0], key_value[1] ) ;
		}
		
		return genfile::SNPDataSource::UniquePtr( source.release() ) ;
	}
	
	std::auto_ptr< SNPDictionary > load_snp_dictionary( std::string const& filename ) const {
		std::auto_ptr< SNPDictionary > result( new SNPDictionary ) ;
		statfile::BuiltInTypeStatSource::UniquePtr source( 
			statfile::BuiltInTypeStatSource::open(
				genfile::wildcard::find_files_by_chromosome( filename )
			).release()
		) ;
		
		appcontext::UIContext::ProgressContext progress_context = m_ui_context.get_progress_context( "Opening position translation dictionary" ) ;
		
		if( !source->number_of_columns() == 10 ) {
			throw genfile::MalformedInputError( filename, 1 ) ;
		}
		
		genfile::SNPIdentifyingData data1, data2 ;
		while(
			(*source)
				>> data1.SNPID() >> data1.rsid()
				>> data1.position().chromosome() >> data1.position().position()
				>> data1.first_allele() >> data1.second_allele()
				>> data2.SNPID() >> data2.rsid()
				>> data2.position().chromosome() >> data2.position().position()
				>> data2.first_allele() >> data2.second_allele()
		) {
			std::map< genfile::SNPIdentifyingData, genfile::SNPIdentifyingData >::const_iterator where = result->find( data1 ) ;
			if( where != result->end() ) {
				throw genfile::DuplicateSNPError( filename, genfile::string_utils::to_string( data1 ) ) ;
			}
			(*result)[ data1 ] = data2 ;
			(*source) >> statfile::end_row() ;
			progress_context( source->number_of_rows_read(), source->number_of_rows() ) ;
		}
		return result ;
	}
		
	genfile::CommonSNPFilter::UniquePtr get_snp_exclusion_filter() const {
		genfile::CommonSNPFilter::UniquePtr snp_filter ;

		if( m_options.check_if_option_was_supplied_in_group( "SNP exclusion options" )) {
			snp_filter.reset( new genfile::CommonSNPFilter ) ;

			if( m_options.check_if_option_was_supplied( "-excl-snpids" )) {
				snp_filter->exclude_snps_in_file(
					m_options.get_value< std::string >( "-excl-snpids" ),
					genfile::CommonSNPFilter::SNPIDs
				) ;
			}

			if( m_options.check_if_option_was_supplied( "-excl-rsids" )) {
				snp_filter->exclude_snps_in_file(
					m_options.get_value< std::string >( "-excl-rsids" ),
					genfile::CommonSNPFilter::RSIDs
				) ;
			}

			if( m_options.check_if_option_was_supplied( "-incl-snpids" )) {
				snp_filter->exclude_snps_not_in_file(
					m_options.get_value< std::string >( "-incl-snpids" ),
					genfile::CommonSNPFilter::SNPIDs
				) ;
			}

			if( m_options.check_if_option_was_supplied( "-incl-rsids" )) {
				snp_filter->exclude_snps_not_in_file(
					m_options.get_value< std::string >( "-incl-rsids" ),
					genfile::CommonSNPFilter::RSIDs
				) ;
			}

			if( m_options.check_if_option_was_supplied( "-excl-snps-matching" )) {
				snp_filter->exclude_snps_matching(
					m_options.get_value< std::string >( "-excl-snps-matching" )
				) ;
			}

			if( m_options.check_if_option_was_supplied( "-incl-snps-matching" )) {
				snp_filter->exclude_snps_not_matching(
					m_options.get_value< std::string >( "-incl-snps-matching" )
				) ;
			}
			
			if( m_options.check_if_option_was_supplied( "-range" )) {
				std::vector< std::string > specs = genfile::string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-range" ), ",", " \t" ) ;
				for ( std::size_t i = 0; i < specs.size(); ++i ) {
					snp_filter->exclude_snps_not_in_range(
						genfile::GenomePositionRange::parse( specs[i] )
					) ;
				}
			}

			if( m_options.check_if_option_was_supplied( "-exclude-range" )) {
				std::vector< std::string > specs = genfile::string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-exclude-range" ), ",", " \t" ) ;
				for ( std::size_t i = 0; i < specs.size(); ++i ) {
					snp_filter->exclude_snps_in_range(
						genfile::GenomePositionRange::parse( specs[i] )
					) ;
				}
			}
		}
		return snp_filter ;
	}
	
	void move_to_next_output_file( std::size_t index ) {
		// Kludge: don't move through outputs until they are actually created.
		// Actually, we only want to move through outputs once during the main
		// processing, but for example id filtering takes place first and has nothing
		// to do with the outputs. On the other hand, filtering should probably
		// happen before the
		if( m_fltrd_in_snp_data_sink.get() ) {
			if( index < m_mangled_options.gen_filename_mapper().input_files().size() ) {
				if( m_mangled_options.gen_filename_mapper().output_filenames().size() > 0 ) {
					if( m_mangled_options.gen_filename_mapper().filename_corresponding_to( index ) != m_fltrd_in_snp_data_sink->index_of_current_sink() ) {
						m_fltrd_in_snp_data_sink->move_to_next_sink() ;
					}
				}
			
				if( m_mangled_options.snp_stats_filename_mapper().output_filenames().size() > 0 ) {
					if( m_mangled_options.snp_stats_filename_mapper().filename_corresponding_to( index ) != m_current_snp_stats_filename_index ) {
						open_snp_stats_sink( ++m_current_snp_stats_filename_index, m_snp_statistics ) ;
					}
				}
			
				if( m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() > 0 ) {
					if( m_mangled_options.snp_excl_list_filename_mapper().filename_corresponding_to( index ) != m_fltrd_out_snp_data_sink->index_of_current_sink() ) {
						m_fltrd_out_snp_data_sink->move_to_next_sink() ;
					}
				}
			}
		}
	}

	void open_snp_data_sinks() {
		open_filtered_in_snp_data_sink() ;
		open_filtered_out_snp_data_sink() ;
	}

	void reset_filtered_in_snp_data_sink() {
		m_fltrd_in_snp_data_sink = std::auto_ptr< genfile::SNPDataSinkChain >( new genfile::SNPDataSinkChain() ) ;
	}

	void open_filtered_in_snp_data_sink() {
		reset_filtered_in_snp_data_sink() ;
		if( m_options.check_if_option_was_supplied( "-op" )) {
			assert( m_options.check_if_option_was_supplied( "-ip" )) ;
			assert( !m_options.check_if_option_was_supplied( "-og" )) ;
			
			m_pedigree = genfile::Pedigree::create(
				"file:" + m_options.get_value< std::string >( "-ip" )
			) ;

			std::string filename = m_options.get_value< std::string >( "-op" ) ;
			if( filename.size() > 4 && filename.substr( filename.size() - 4, 4 ) == ".bed" ) {
				m_fltrd_in_snp_data_sink->add_sink(
					genfile::SNPDataSink::UniquePtr(
						new genfile::BedFileSNPDataSink(
							*m_cohort_individual_source,
							*m_pedigree,
							filename
						)
					)
				) ;
			}
			else {
				m_fltrd_in_snp_data_sink->add_sink(
					genfile::SNPDataSink::UniquePtr(
						new genfile::PedFileSNPDataSink(
							*m_cohort_individual_source,
							*m_pedigree,
							filename
						)
					)
				) ;
			}
		}
		else if( m_mangled_options.gen_filename_mapper().output_filenames().size() == 0 ) {
			m_fltrd_in_snp_data_sink->add_sink( genfile::SNPDataSink::UniquePtr( new genfile::TrivialSNPDataSink() )) ;
		}
		else {
			for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++i ) {
				std::string const& filename = m_mangled_options.gen_filename_mapper().output_filenames()[i] ;
				m_fltrd_in_snp_data_sink->add_sink( genfile::SNPDataSink::create( filename )) ;
			}
		}
	}

	void open_filtered_out_snp_data_sink() {
		reset_filtered_out_snp_data_sink() ;
		if( m_options.check_if_option_was_supplied( "-write-snp-excl-list" ) && m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() > 0 ) {
			for( std::size_t i = 0; i < m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size(); ++i ) {
				std::string const& filename = m_mangled_options.snp_excl_list_filename_mapper().output_filenames()[i] ;
				m_fltrd_out_snp_data_sink->add_sink( genfile::SNPDataSink::UniquePtr( new SNPIDSink( filename ))) ;
			}
		}
		else {
			m_fltrd_out_snp_data_sink->add_sink( genfile::SNPDataSink::UniquePtr( new genfile::TrivialSNPDataSink() )) ;
		}
	}

	void reset_filtered_out_snp_data_sink() {
		m_fltrd_out_snp_data_sink.reset( new genfile::SNPDataSinkChain() ) ;
	}

	void open_sample_row_sink() {
		m_fltrd_in_sample_sink.reset( new NullObjectSink< SampleRow >() ) ;
		if( m_mangled_options.output_sample_filename() != "" ) {
			m_backup_creator.backup_file_if_necessary( m_mangled_options.output_sample_filename() ) ;
			m_fltrd_in_sample_sink.reset( new SampleOutputFile< SimpleFileObjectSink< SampleRow > >( open_file_for_output( m_mangled_options.output_sample_filename() ))) ;
		}
		
		m_fltrd_out_sample_sink.reset( new NullObjectSink< SampleRow >() ) ;
		if( m_mangled_options.output_sample_excl_list_filename() != "" ) {
			m_fltrd_out_sample_sink.reset( new SampleIDSink( open_file_for_output( m_mangled_options.output_sample_excl_list_filename() ))) ;
		}
	}

	void open_snp_stats_sink( std::size_t index, GenRowStatistics const& snp_statistics ) {
		if( m_mangled_options.snp_stats_filename_mapper().output_filenames().size() == 0 ) {
			m_snp_stats_sink.reset( new statfile::TrivialBuiltInTypeStatSink() ) ;
		}
		else {
			assert( index < m_mangled_options.snp_stats_filename_mapper().output_filenames().size()) ;
			m_current_snp_stats_filename_index = index ;
			statfile::RFormatStatSink::UniquePtr sink( new statfile::RFormatStatSink( m_mangled_options.snp_stats_filename_mapper().output_filenames()[ index ] )) ;
			m_snp_stats_sink.reset( sink.release() ) ;
		}
		for( std::size_t i = 0; i < snp_statistics.size(); ++i ) {
			m_snp_stats_sink->add_column( snp_statistics.get_statistic_name( i )) ;
		}
	}

	void reset_snp_stats_sink() {
		m_snp_stats_sink.reset() ;
	}

	void open_sample_stats_sink() {
		if( m_mangled_options.output_sample_stats_filename() == "" ) {
			m_sample_stats_sink.reset( new statfile::TrivialBuiltInTypeStatSink() ) ;
		}
		else {
			statfile::RFormatStatSink::UniquePtr sink( new statfile::RFormatStatSink( m_mangled_options.output_sample_stats_filename() )) ;
			m_sample_stats_sink.reset( sink.release() ) ;
		}
		m_sample_stats_sink->add_column( "" ) ;
		for( std::size_t i = 0; i < m_sample_statistics.size(); ++i ) {
			m_sample_stats_sink->add_column( m_sample_statistics.get_statistic_name( i )) ;
		}
	}
	
	void reset_sample_stats_sink() {
		m_sample_stats_sink.reset() ;
	}

	void construct_snp_statistics() {
		GenRowStatisticFactory::add_statistics( m_mangled_options.row_statistics_specs(), m_snp_statistics ) ;
	}

	void construct_sample_statistics() {
		std::vector< std::string > sample_statistics_specs = string_utils::split_and_strip_discarding_empty_entries( m_options.get_value< std::string >( "-sample-stats-columns" ), "," ) ;
		SampleRowStatisticFactory::add_statistics( sample_statistics_specs, m_sample_statistics ) ;
	}

	void construct_snp_filter() {
		std::auto_ptr< AndRowCondition > snp_filter( new AndRowCondition() ) ;

		if( m_options.check_if_option_was_supplied( "-hwe" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *snp_filter, "HWE", m_options.get_value< double >( "-hwe" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-info" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *snp_filter, "information", m_options.get_values< double >( "-info" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-snp-missing-rate" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *snp_filter, "missing", m_options.get_value< double >( "-snp-missing-rate" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-snp-missing-call-rate" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *snp_filter, "missing_calls", m_options.get_value< double >( "-snp-missing-call-rate" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-snp-interval" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *snp_filter, "snp-position", m_options.get_values< double >( "-snp-interval" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-maf" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *snp_filter, "MAF", m_options.get_values< double >( "-maf" )) ;
		}

		m_snp_filter = snp_filter ;
		m_snp_filter_failure_counts.resize( m_snp_filter->number_of_subconditions(), 0 ) ;
	}

	void construct_sample_filter() {
		std::auto_ptr< AndRowCondition > sample_filter( new AndRowCondition() ) ;
		
		if( m_options.check_if_option_was_supplied( "-sample-missing-rate" ) ) {
			add_one_arg_condition_to_filter< StatisticLessThan >( *sample_filter, "missing", m_options.get_value< double >( "-sample-missing-rate" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-heterozygosity" ) ) {
			add_two_arg_condition_to_filter< StatisticInInclusiveRange >( *sample_filter, "heterozygosity", m_options.get_values< double >( "-heterozygosity" )) ;
		}

		if( m_options.check_if_option_was_supplied( "-incl-samples" ) ) {
			std::vector< std::string > filenames = m_options.get_values< std::string >( "-incl-samples" ) ;
			for( std::size_t i = 0; i < filenames.size(); ++i ) {
				std::auto_ptr< RowCondition > sample_incl_condition( new SampleInListCondition( filenames[i] )) ;
				sample_filter->add_subcondition( sample_incl_condition ) ;
			}
		}

		if( m_options.check_if_option_was_supplied( "-excl-samples" ) ) {
			std::vector< std::string > filenames = m_options.get_values< std::string >( "-excl-samples" ) ;
			for( std::size_t i = 0; i < filenames.size(); ++i ) {
				std::auto_ptr< RowCondition > sample_incl_condition( new SampleInListCondition( filenames[i] )) ;
				std::auto_ptr< RowCondition > sample_excl_condition( new NotRowCondition( sample_incl_condition )) ;
				sample_filter->add_subcondition( sample_excl_condition ) ;
			}
		}
		
		m_sample_filter = sample_filter ;
		m_sample_filter_failure_counts.resize( m_sample_filter->number_of_subconditions(), 0 ) ;
	}

	template< typename ConditionType >
	void add_one_arg_condition_to_filter( AndRowCondition& filter, std::string const& statistic_name, double value ) {
		std::auto_ptr< RowCondition > condition( new ConditionType( statistic_name, value )) ;
		filter.add_subcondition( condition ) ;
	}

	template< typename ConditionType >
	void add_two_arg_condition_to_filter( AndRowCondition& filter, std::string const& statistic_name, std::vector< double > values ) {
		assert( values.size() == 2 ) ;
		std::auto_ptr< RowCondition > condition( new ConditionType( statistic_name, values[0], values[1] )) ;
		filter.add_subcondition( condition ) ;
	}

	void process_other_options() {
		m_ignore_warnings = m_options.check_if_option_was_supplied( "-force" ) ;
	}
	
	genfile::CohortIndividualSource::UniquePtr load_sample_rows( std::size_t const expected_number_of_samples ) {
		
		try {
			return unsafe_load_sample_rows( expected_number_of_samples ) ;
		}
		catch( ConditionValueNotFoundException const& ) {
			m_ui_context.logger() << "\n\n!! ERROR: The input sample file must contain entries for all values used to filter on.\n"
				<< "!! This includes \"missing\" and \"heterozygosity\".\n" ;
			throw ;
		}
		catch( genfile::MalformedInputError const& e ) {
			m_ui_context.logger() << "\n\n!! ERROR (" << e.what() << "): the sample file \"" << e.source() << "\" is malformed on line "
				<< e.line() + 1 ;
			if( e.has_column() ) {
				m_ui_context.logger() << ", column " << e.column() + 1 ;
			}
			m_ui_context.logger() << ".  Quitting.\n" ;
			throw ;
		}
	}
	
	genfile::CohortIndividualSource::UniquePtr unsafe_load_sample_rows( std::size_t const expected_number_of_samples ) {
		genfile::CohortIndividualSource::UniquePtr sample_source ;
		if( m_mangled_options.input_sample_filenames().size() > 0 ) {
			genfile::CohortIndividualSourceChain::UniquePtr source_chain( new genfile::CohortIndividualSourceChain() ) ;
			for( std::size_t i = 0; i < m_mangled_options.input_sample_filenames().size(); ++i ) {
				source_chain->add_source(
					genfile::CohortIndividualSource::UniquePtr(
						new genfile::CategoricalCohortIndividualSource(
							m_mangled_options.input_sample_filenames()[i],
							m_options.get_value< std::string >( "-missing-code" )
						)
					)
				) ;
			}
			sample_source.reset( source_chain.release() ) ;
			
			if( m_options.check_if_option_was_supplied( "-quantile-normalise" )) {
				sample_source = quantile_normalise_columns(
					sample_source,
					genfile::string_utils::split_and_strip(
						m_options.get_value< std::string >( "-quantile-normalise" ),
						","
					)
				) ;
			}
			
			SampleRow sample_row ;
			for( std::size_t i = 0; i < sample_source->get_number_of_individuals(); ++i ) {
				sample_row.read_ith_sample_from_source( i, *sample_source ) ;
				m_sample_rows.push_back( sample_row ) ;
				if( !m_sample_filter->check_if_satisfied( sample_row )) {
					m_indices_of_filtered_out_samples.push_back( m_sample_rows.size() - 1 ) ;
				}
			}
			if( m_sample_rows.size() != expected_number_of_samples ) {
				throw NumberOfSamplesMismatchException() ;
			}
		}
		else {
			m_sample_rows.resize( expected_number_of_samples ) ;
		}
		return sample_source ;
	}
	
	genfile::CohortIndividualSource::UniquePtr quantile_normalise_columns(
		genfile::CohortIndividualSource::UniquePtr source,
		std::vector< std::string > const& column_names
	) const {
		genfile::ValueMappingCohortIndividualSource::UniquePtr value_mapping_source(
			new genfile::ValueMappingCohortIndividualSource( source )
		) ;
		for( std::size_t i = 0; i < column_names.size(); ++i ) {
			add_normalisation( *value_mapping_source, column_names[i] ) ;
		}
		return genfile::CohortIndividualSource::UniquePtr( value_mapping_source.release() ) ;
	}

 	void add_normalisation(
		genfile::ValueMappingCohortIndividualSource& source,
		std::string const& column_name
	) const {
		genfile::CohortIndividualSource::ColumnSpec column_spec = source.get_column_spec() ;
		std::size_t column_i = column_spec.find_column( column_name ) ;
		if( !column_spec[ column_i ].is_continuous() ) {
			throw genfile::BadArgumentError( "qctool::quantile_normalise_columns()", "column_name = \"" + column_name + "\"" ) ;
		}
		genfile::CrossCohortCovariateValueMapping::UniquePtr mapping(
			new genfile::QuantileNormalisingCrossCohortCovariateValueMapping( column_name )
		) ;
		mapping->add_source( source ) ;
		source.add_mapping( column_name, mapping ) ;
	}

	void check_for_errors_and_warnings() {
		check_for_errors() ;
		check_for_warnings() ;
	}

	void check_for_errors() {
		if( m_mangled_options.gen_filename_mapper().input_files().size() == 0 ) {
			m_errors.push_back( "At least one GEN input file must be supplied." ) ;
		}

		for( std::size_t i = 0; i < m_mangled_options.gen_filename_mapper().input_files().size(); ++i ) {
			for( std::size_t j = 0; j < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++j ) {
				if( strings_are_nonempty_and_equal( m_mangled_options.gen_filename_mapper().output_filenames()[j], m_mangled_options.gen_filename_mapper().input_file( i ).filename() )) {
					m_errors.push_back( "Output GEN file \"" + m_mangled_options.gen_filename_mapper().output_filenames()[j] +"\" also specified as input GEN file." ) ;
					break ;
				}
			}
			if( strings_are_nonempty_and_equal( m_mangled_options.output_sample_filename(), m_mangled_options.gen_filename_mapper().input_file( i ).filename() )) {
				m_errors.push_back( "Output SAMPLE file \"" + m_mangled_options.output_sample_filename() +"\" also specified as input GEN file." ) ;
				break ;
			}
			for( std::size_t j = 0; j < m_mangled_options.snp_stats_filename_mapper().output_filenames().size(); ++j ) {
				if( strings_are_nonempty_and_equal( m_mangled_options.snp_stats_filename_mapper().output_filenames()[j], m_mangled_options.gen_filename_mapper().input_file( i ).filename() )) {
					m_errors.push_back( "Output GEN statistic file \"" + m_mangled_options.snp_stats_filename_mapper().output_filenames()[j] +"\" also specified as input GEN file." ) ;
					break ;
				}
			}
			if( strings_are_nonempty_and_equal( m_mangled_options.output_sample_stats_filename(), m_mangled_options.gen_filename_mapper().input_file( i ).filename() )) {
				m_errors.push_back( "Output SAMPLE statistic file \"" + m_mangled_options.output_sample_stats_filename() +"\" also specified as input GEN file." ) ;
				break ;
			}
		}
		for( std::size_t j = 0; j < m_mangled_options.gen_filename_mapper().output_filenames().size(); ++j ) {
			if( strings_are_nonempty_and_equal( m_mangled_options.output_sample_filename(), m_mangled_options.gen_filename_mapper().output_filenames()[j] )) {
				m_errors.push_back( "The GEN and SAMPLE output filenames must differ." ) ;
			}
		}
		for( std::size_t j = 0; j < m_mangled_options.snp_stats_filename_mapper().output_filenames().size(); ++j ) {
			if( strings_are_nonempty_and_equal( m_mangled_options.snp_stats_filename_mapper().output_filenames()[j], m_mangled_options.output_sample_stats_filename() )) {
				m_errors.push_back( "The gen statistic and sample statistic filenames must differ." ) ;
			}
		}
		if( m_mangled_options.input_sample_filenames().size() == 0 && m_sample_filter->number_of_subconditions() != 0 ) {
			m_errors.push_back( "To filter on samples, please supply input sample files." ) ;
		}
		if( m_options.check_if_option_was_supplied_in_group( "Sample filtering options") && m_mangled_options.output_sample_excl_list_filename() == "" && m_mangled_options.gen_filename_mapper().output_filenames().size() == 0 && m_mangled_options.snp_stats_filename_mapper().output_filenames().size() == 0 && m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() == 0 ) {
			m_errors.push_back( "You have specified sample filters, but not an output sample or SNP exclusion list, nor any output GEN files, nor any output SNP statistic files." ) ;
		}
		if( m_snp_filter->number_of_subconditions() > 0 && m_mangled_options.snp_excl_list_filename_mapper().output_filenames().size() == 0 && m_mangled_options.gen_filename_mapper().output_filenames().size() == 0 ) {
			m_errors.push_back( "You have specified SNP filters, but no output SNP exclusion list or output GEN files.\n" ) ;
		}
	}
	
	void check_for_warnings() {
		if( m_mangled_options.output_sample_stats_filename() != "" && m_mangled_options.input_sample_filenames().size() == 0 ) {
			m_warnings.push_back( "You are outputting a sample statistic file, but no input sample files have been supplied.\n"
			"   Statistics will be output but the ID fields will be left blank.") ;
		}
		if( m_snp_data_source->total_number_of_snps() == 0 ) {
			m_warnings.push_back( "There are no SNPs in the source files (after exclusions, translation, aligning and matching between cohorts where relevant).\n" ) ;
		}
		if( m_sample_rows.size() == 0 ) {
			m_warnings.push_back( "There are no individuals in the source files (after exclusions, translation, aligning and matching between cohorts where relevant).\n" ) ;
		}
	}
	
	bool strings_are_nonempty_and_equal( std::string const& left, std::string const& right ) {
		return (!left.empty()) && (!right.empty()) && (left == right) ;
	}

} ;

struct QCToolApplication: public appcontext::ApplicationContext
{
public:
	QCToolApplication( int argc, char** argv ):
		appcontext::ApplicationContext( globals::program_name, globals::program_version, std::auto_ptr< appcontext::OptionProcessor >( new QCToolOptionProcessor ), argc, argv, "-log" )
	{
		process() ;
	}
	
private:
	
	void process() {
		try {
			unsafe_process() ;
		}
		catch( genfile::InputError const& e ) {
			get_ui_context().logger() << "!! Error (" << e.what() << "): " << e.format_message() << ".\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
		catch( genfile::FileNotFoundError const& e ) {
			get_ui_context().logger() << "\nError: No file matching \"" << e.filespec() << "\" could be found.\n" ;
			throw appcontext::HaltProgramWithReturnCode( -1 ) ;
		}
	}
	
	void unsafe_process() {
		std::size_t const number_of_threads = options().get_value< std::size_t >( "-threads" ) ;
		worker::Worker::UniquePtr worker ;
		if( number_of_threads > 0 ) {
			worker.reset( new worker::QueuedMultiThreadedWorker( number_of_threads )) ;
		} else {
			worker.reset( new worker::SynchronousWorker() ) ;
		}

		QCToolCmdLineContext context(
			options(),
			get_ui_context()
		) ;

		QCTool qctool_basic(
			context,
			get_ui_context()
		) ;
		
		genfile::SimpleSNPDataSourceProcessor processor ;

		if(
			options().check_if_option_was_supplied( "-snp-stats" )
			|| options().check_if_option_was_supplied( "-sample-stats" )
			|| options().check_if_option_was_supplied( "-og" )
			|| options().check_if_option_was_supplied( "-op" )
			|| options().check_if_option_was_supplied( "-os" )
			|| options().check_if_option_was_supplied( "-op" )
			|| options().check_if_option_was_supplied_in_group( "SNP filtering options" )
		) {
			processor.add_callback( qctool_basic ) ;
		}
		
		std::auto_ptr< DataReadTest > data_read_test ;
		if( options().check_if_option_was_supplied( "-read-test" )) {
			data_read_test.reset( new DataReadTest() ) ;
			processor.add_callback( *data_read_test ) ;
		}
		
		std::auto_ptr< Relatotron > relatotron ;
		if( options().check_if_option_was_supplied_in_group( "Relatedness options" )) {
			relatotron.reset( new Relatotron( options(), context.get_cohort_individual_source(), get_ui_context() )) ;
			processor.add_callback( *relatotron ) ;
		}

		std::auto_ptr< AssociationTester > association_tester ;
		if( options().check_if_option_was_supplied( "-test" )) {
			association_tester.reset( new AssociationTester( options(), context.get_cohort_individual_source(), get_ui_context() )) ;
			processor.add_callback( *association_tester ) ;
		}

		std::auto_ptr< VCDBWriter > db_writer ;
		if( options().check_if_option_was_supplied( "-write-db" )) {
			db_writer = VCDBWriter::create( options() ) ;
			processor.add_callback( *db_writer ) ;
		}

		KinshipCoefficientManager::UniquePtr kinship ;
		if( options().check_if_option_was_supplied_in_group( "Kinship options" )) {
			kinship = KinshipCoefficientManager::create(
				options(),
				context.get_cohort_individual_source(),
				worker.get(),
				get_ui_context()
			) ;
			processor.add_callback( *kinship )  ;
		}

		ClusterFitter::UniquePtr cluster_fitter ;
		if( options().check_if_option_was_supplied( "-fit-clusters" ) ) {
			cluster_fitter = ClusterFitter::create( options() ) ;
			processor.add_callback( *cluster_fitter ) ;
		}

		CallComparerComponent::UniquePtr call_comparer_component ;
		if( options().check_if_option_was_supplied_in_group( "Call comparison options" ))  {
			call_comparer_component = CallComparerComponent::create( options() ) ;
			processor.add_callback( *call_comparer_component ) ;
			processor.add_callback( call_comparer_component->get_comparer() ) ;
			if( cluster_fitter.get() ) {
				
			}
		}
		
		ClusterPlotter::UniquePtr cluster_plotter ;
		if( options().check_if_option_was_supplied_in_group( "Cluster plot options" )) {
			cluster_plotter = ClusterPlotter::create( options(), worker.get() ) ;
			processor.add_callback( *cluster_plotter ) ;
		}

		// Process it!
		{
			UIContext::ProgressContext progress_context = get_ui_context().get_progress_context( "Processing SNPs" ) ;
			processor.process( context.snp_data_source(), progress_context ) ;
		}
		
		if( relatotron.get() ) {
			relatotron->process( worker.get() ) ;
		}
	}
} ;


int main( int argc, char** argv ) {
    try {
		QCToolApplication app( argc, argv ) ;
    }
	catch( appcontext::HaltProgramWithReturnCode const& e ) {
		return e.return_code() ;
	}
	return 0 ;
}
