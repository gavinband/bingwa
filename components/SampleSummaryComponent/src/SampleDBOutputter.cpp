#include <string>
#include <memory>
#include <boost/shared_ptr.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/thread/thread.hpp>
#include "genfile/VariantEntry.hpp"
#include "genfile/Error.hpp"
#include "db/Connection.hpp"
#include "db/SQLStatement.hpp"
#include "components/SampleSummaryComponent/SampleDBOutputter.hpp"
#include "qcdb/DBOutputter.hpp"
#include "../../qctool_version_autogenerated.hpp"

namespace impl {
	SampleDBOutputter::UniquePtr SampleDBOutputter::create( std::string const& filename, std::string const& cohort_name, std::string const& data_source_spec, std::string const& exclusions_name ) {
		return UniquePtr( new SampleDBOutputter( filename, cohort_name, data_source_spec, exclusions_name ) ) ;
	}
	SampleDBOutputter::SharedPtr SampleDBOutputter::create_shared( std::string const& filename, std::string const& cohort_name, std::string const& data_source_spec, std::string const& exclusions_name ) {
		return SharedPtr( new SampleDBOutputter( filename, cohort_name, data_source_spec, exclusions_name ) ) ;
	}

	SampleDBOutputter::SampleDBOutputter( std::string const& filename, std::string const& cohort_name, std::string const& data_source_spec, std::string const& exclusions_name ):
		qcdb::DBOutputter( filename, cohort_name, data_source_spec, exclusions_name ),
		m_max_transaction_count( 10000 )
	{
		db::Connection::ScopedTransactionPtr transaction = m_connection->open_transaction( 30 ) ;
		m_connection->run_statement(
			"CREATE TABLE IF NOT EXISTS Sample ( "
				"id INTEGER PRIMARY KEY, "
				"identifier TEXT, "
				"UNIQUE( identifier )"
			")"
		) ;

		m_connection->run_statement(
			"CREATE TABLE IF NOT EXISTS SampleData ( "
				"analysis_id INTEGER NOT NULL, "
				"sample_id INTEGER NOT NULL, "
				"variable_id INTEGER NOT NULL, "
				"value TEXT, "
				"FOREIGN KEY( analysis_id ) REFERENCES Entity( id ), "
				"FOREIGN KEY( sample_id ) REFERENCES Sample( id ), "
				"FOREIGN KEY( variable_id ) REFERENCES Entity( id ), "
				"UNIQUE( analysis_id, sample_id, variable_id )"
			")"
		) ;
		construct_statements() ;
	}

	void SampleDBOutputter::construct_statements() {
		m_find_sample_statement = m_connection->get_statement( "SELECT id FROM Sample WHERE identifier == ?1" ) ;
		m_insert_sample_statement = m_connection->get_statement( "INSERT INTO Sample (identifier) VALUES( ?1 )" ) ;
		m_insert_sampledata_statement = m_connection->get_statement(
			"INSERT OR REPLACE INTO SampleData ( analysis_id, sample_id, variable_id, value ) "
			"VALUES( ?1, ?2, ?3, ?4 )"
		) ;
	}

	SampleDBOutputter::~SampleDBOutputter() {}

	void SampleDBOutputter::store_samples( genfile::CohortIndividualSource const& samples ) {
		db::Connection::ScopedTransactionPtr transaction = m_connection->open_transaction( 100 ) ; // wait 100 seconds.
		if( !transaction.get() ) {
			throw genfile::OperationFailedError( "SampleDBOutputter::store_samples()", m_connection->get_spec(), "Opening transaction." ) ;
		}
		
		for( std::size_t i = 0; i < samples.get_number_of_individuals(); ++i ) {
			store_sample( samples, i ) ;
		}
	}

	void SampleDBOutputter::store_sample( genfile::CohortIndividualSource const& samples, std::size_t sample ) {
		db::Connection::RowId sample_id = get_or_create_sample( samples.get_entry( sample, "ID_1" ) ) ;
		genfile::CohortIndividualSource::ColumnSpec spec = samples.get_column_spec() ;
		for( std::size_t i = 0; i < spec.size(); ++i ) {
			db::Connection::RowId variable_id = get_or_create_variable( spec[i].name(), "Per-sample " + spec[i].name() + " values" ) ;

			m_insert_sampledata_statement
				->bind( 1, m_analysis_id )
				.bind( 2, sample_id )
				.bind( 3, spec[i].name() )
				.bind( 4, samples.get_entry( sample, spec[i].name() )
			) ;

			m_insert_sampledata_statement->reset() ;
		}
	}

	db::Connection::RowId SampleDBOutputter::get_or_create_sample( genfile::VariantEntry const& identifier ) const {
		db::Connection::RowId result ;

		if( identifier.is_missing() ) {
			throw genfile::BadArgumentError( "impl::SampleDBOutputter::get_or_create_sample()", "identifier=NA" ) ;
		}

		m_find_sample_statement
			->bind( 1, identifier )
			.step() ;

		if( m_find_sample_statement->empty() ) {
			m_insert_sample_statement
				->bind( 1, identifier  )
				.step() ;
				
			result = m_connection->get_last_insert_row_id() ;

			m_insert_sample_statement->reset() ;
		}
		else {
			result = m_find_sample_statement->get< db::Connection::RowId >( 0 ) ;
		}

		m_find_sample_statement->reset() ;

		return result ;
	}
}
