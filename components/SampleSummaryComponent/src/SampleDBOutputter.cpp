#include <string>
#include <memory>
#include <boost/shared_ptr.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/thread/thread.hpp>
#include "genfile/VariantEntry.hpp"
#include "genfile/Error.hpp"
#include "db/Connection.hpp"
#include "db/SQLStatement.hpp"
#include "components/SampleSummaryComponent/SampleDBOutputter.hpp"
#include "../../qctool_version_autogenerated.hpp"

namespace impl {
	SampleDBOutputter::UniquePtr SampleDBOutputter::create( std::string const& filename, std::string const& cohort_name, std::string const& data_source_spec, std::string const& exclusions_name ) {
		return UniquePtr( new SampleDBOutputter( filename, cohort_name, data_source_spec, exclusions_name ) ) ;
	}
	SampleDBOutputter::SharedPtr SampleDBOutputter::create_shared( std::string const& filename, std::string const& cohort_name, std::string const& data_source_spec, std::string const& exclusions_name ) {
		return SharedPtr( new SampleDBOutputter( filename, cohort_name, data_source_spec, exclusions_name ) ) ;
	}

	SampleDBOutputter::SampleDBOutputter( std::string const& filename, std::string const& cohort_name, std::string const& data_source_spec, std::string const& exclusions_name ):
		m_connection( db::Connection::create( filename )),
		m_max_transaction_count( 10000 ),
		m_cohort_name( cohort_name ),
		m_source_spec( data_source_spec ),
		m_exclusions_name( exclusions_name )
	{
		db::Connection::ScopedTransactionPtr transaction = m_connection->open_transaction( 30 ) ;
		m_connection->run_statement(
			"CREATE TABLE IF NOT EXISTS Entity ( id INTEGER PRIMARY KEY, name TEXT, description TEXT )"
		) ;
		m_connection->run_statement(
			"CREATE TABLE IF NOT EXISTS EntityData ( "
			"entity_id INTEGER NOT NULL, "
			"variable_id INTEGER NOT NULL, "
			"value TEXT, "
			"FOREIGN KEY (entity_id) REFERENCES Entity( id ), "
			"FOREIGN KEY (variable_id) REFERENCES Entity( id ) "
			")"
		) ;
		m_connection->run_statement(
			"CREATE TABLE IF NOT EXISTS Sample ( "
				"id INTEGER PRIMARY KEY, "
				"identifier TEXT, "
				"UNIQUE( identifier )"
			")"
		) ;

		m_connection->run_statement(
			"CREATE TABLE IF NOT EXISTS SampleData ( "
				"analysis_id INTEGER NOT NULL, "
				"sample_id INTEGER NOT NULL, "
				"variable_id INTEGER NOT NULL, "
				"value TEXT, "
				"FOREIGN KEY( analysis_id ) REFERENCES Entity( id ), "
				"FOREIGN KEY( sample_id ) REFERENCES Sample( id ), "
				"FOREIGN KEY( variable_id ) REFERENCES Entity( id ), "
				"UNIQUE( analysis_id, sample_id, variable_id )"
			")"
		) ;
		construct_statements() ;
		
		m_analysis_id = get_or_create_entity( m_cohort_name ) ;
		get_or_create_entity_data( m_analysis_id, get_or_create_entity( "data_source" ), m_source_spec ) ;
		if( m_exclusions_name != "" ) {
			get_or_create_entity_data( m_analysis_id, get_or_create_entity( "sample_exclusions" ), m_exclusions_name ) ;
		}
		
		reset_statements() ;
	}

	SampleDBOutputter::~SampleDBOutputter() {}

	void SampleDBOutputter::store_samples( genfile::CohortIndividualSource const& samples ) {
		db::Connection::ScopedTransactionPtr transaction = m_connection->open_transaction( 100 ) ; // wait 100 seconds.
		if( !transaction.get() ) {
			throw genfile::OperationFailedError( "SampleDBOutputter::store_samples()", m_connection->get_spec(), "Opening transaction." ) ;
		}
		
		for( std::size_t i = 0; i < samples.get_number_of_individuals(); ++i ) {
			store_sample( samples, i ) ;
		}
	}

	void SampleDBOutputter::store_sample( genfile::CohortIndividualSource const& samples, std::size_t sample ) {
		db::Connection::RowId sample_id = get_or_create_sample( samples.get_entry( sample, "ID_1" ) ) ;
		genfile::CohortIndividualSource::ColumnSpec spec = samples.get_column_spec() ;
		for( std::size_t i = 0; i < spec.size(); ++i ) {
			db::Connection::RowId variable_id = get_or_create_variable( spec[i].name(), "Per-sample " + spec[i].name() + " values" ) ;

			m_insert_sampledata_statement
				->reset()
				.bind( 1, m_analysis_id )
				.bind( 2, sample_id )
				.bind( 3, spec[i].name() )
				.bind( 4, samples.get_entry( sample, spec[i].name() )
			) ;
		}
	}

	void SampleDBOutputter::construct_statements() {
		m_find_sample_statement = m_connection->get_statement( "SELECT id FROM Sample WHERE identifier == ?1" ) ;
		m_insert_sample_statement = m_connection->get_statement( "INSERT INTO Sample (identifier) VALUES( ?1 )" ) ;
		m_find_entity_statement = m_connection->get_statement( "SELECT * FROM Entity E WHERE name == ?1" ) ;
		m_find_entity_with_description_statement = m_connection->get_statement( "SELECT * FROM Entity E WHERE name == ?1 AND description == ?2" ) ;
		m_insert_entity_statement = m_connection->get_statement( "INSERT INTO Entity ( name, description ) VALUES ( ?1, ?2 )" ) ;
		m_find_entity_data_statement = m_connection->get_statement( "SELECT * FROM EntityData WHERE entity_id == ?1 AND variable_id == ?2" ) ;
		m_insert_entity_data_statement = m_connection->get_statement( "INSERT OR REPLACE INTO EntityData ( entity_id, variable_id, value ) VALUES ( ?1, ?2, ?3 )" ) ;
		m_insert_sampledata_statement = m_connection->get_statement(
			"INSERT OR REPLACE INTO SampleData ( analysis_id, sample_id, variable_id, value ) "
			"VALUES( ?1, ?2, ?3, ?4 )"
		) ;
	}

	void SampleDBOutputter::reset_statements() {
		m_find_sample_statement->reset() ;
		m_insert_sample_statement->reset() ;
		m_find_entity_statement->reset() ;
		m_find_entity_with_description_statement->reset() ;
		m_insert_entity_statement->reset() ;
		m_find_entity_data_statement->reset() ;
		m_insert_entity_data_statement->reset() ;
		m_insert_sampledata_statement->reset() ;
	}
	
	db::Connection::RowId SampleDBOutputter::get_or_create_sample( genfile::VariantEntry const& identifier ) const {
		db::Connection::RowId result ;

		if( identifier.is_missing() ) {
			throw genfile::BadArgumentError( "impl::SampleDBOutputter::get_or_create_sample()", "identifier=NA" ) ;
		}

		m_find_sample_statement->reset()
			.bind( 1, identifier )
			.step() ;
		if( m_find_sample_statement->empty() ) {
			m_insert_sample_statement
				->reset()
				.bind( 1, identifier  )
				.step() ;
				
			result = m_connection->get_last_insert_row_id() ;
		}
		else {
			result = m_find_sample_statement->get< db::Connection::RowId >( 0 ) ;
		}
		return result ;
	}

	db::Connection::RowId SampleDBOutputter::get_or_create_variable( std::string const& name, std::string const& description ) const {
		db::Connection::RowId result ;

		m_find_entity_with_description_statement
			->reset()
			.bind( 1, name )
			.bind( 2, description )
			.step() ;

		if( m_find_entity_with_description_statement->empty() ) {
			m_insert_entity_statement
				->reset()
				.bind( 1, name )
				.bind( 2, description )
				.step() ;
				
			result = m_connection->get_last_insert_row_id() ;
			
			m_insert_entity_data_statement
				->reset()
				.bind( 1, result )
				.bind( 2, get_or_create_entity( "tool" ))
				.bind( 3, "qctool revision " + std::string( globals::qctool_revision ) )
				.step()
			;
		} else {
			result = m_find_entity_statement->get< db::Connection::RowId >( 0 ) ;
		}
		return result ;
	}

	db::Connection::RowId SampleDBOutputter::get_or_create_entity( std::string const& name, std::string const& description ) const {
		db::Connection::RowId result ;

		m_find_entity_statement
			->reset()
			.bind( 1, name ).step() ;

		if( m_find_entity_statement->empty() ) {
			m_insert_entity_statement
				->reset()
				.bind( 1, name )
				.bind( 2, description )
				.step() ;
				
			result = m_connection->get_last_insert_row_id() ;
		} else {
			result = m_find_entity_statement->get< db::Connection::RowId >( 0 ) ;
		}
		return result ;
	}

	db::Connection::RowId SampleDBOutputter::get_or_create_entity_data( db::Connection::RowId const entity_id, db::Connection::RowId const variable_id, genfile::VariantEntry const& value ) const {
		db::Connection::RowId result ;

		m_find_entity_data_statement
			->reset()
			.bind( 1, entity_id )
			.bind( 2, variable_id ).step() ;

		if( m_find_entity_data_statement->empty() ) {
			m_insert_entity_data_statement
				->reset()
				.bind( 1, entity_id )
				.bind( 2, variable_id )
				.bind( 3, value )
				.step() ;
			result = m_connection->get_last_insert_row_id() ;
		} else {
			result = m_find_entity_data_statement->get< db::Connection::RowId >( 0 ) ;
		}
		return result ;
	}
}
