
//          Copyright Gavin Band 2008 - 2012.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)

#include <string>
#include <memory>
#include <boost/shared_ptr.hpp>
#include <boost/tuple/tuple.hpp>
#include <boost/thread/thread.hpp>
#include "genfile/SNPIdentifyingData2.hpp"
#include "genfile/VariantEntry.hpp"
#include "genfile/Error.hpp"
#include "db/Connection.hpp"
#include "db/SQLStatement.hpp"
#include "appcontext/get_current_time_as_string.hpp"
#include "components/SNPSummaryComponent/DBOutputter.hpp"
#include "../../qctool_version_autogenerated.hpp"

namespace snp_summary_component {
	DBOutputter::UniquePtr DBOutputter::create( std::string const& filename, std::string const& analysis_name, std::string const& analysis_description, Metadata const& metadata ) {
		return UniquePtr( new DBOutputter( filename, analysis_name, analysis_description, metadata ) ) ;
	}
	DBOutputter::SharedPtr DBOutputter::create_shared( std::string const& filename, std::string const& analysis_name, std::string const& analysis_description, Metadata const& metadata ) {
		return SharedPtr( new DBOutputter( filename, analysis_name, analysis_description, metadata ) ) ;
	}

	DBOutputter::DBOutputter( std::string const& filename, std::string const& analysis_name, std::string const& analysis_description, Metadata const& metadata ):
		m_outputter( filename, analysis_name, analysis_description, metadata ),
		m_max_transaction_count( 10000 ),
		m_variable_id( m_outputter.get_or_create_entity( "per-variant variable", "per-variant variable values" ) )
	{
	}

	DBOutputter::~DBOutputter() {
		// Re-finalise.
		write_data( m_data ) ;
		m_data.clear() ;
	}
	
	void DBOutputter::finalise( long options ) {
		write_data( m_data ) ;
		m_data.clear() ;
		m_outputter.finalise( options ) ;
	}

	void DBOutputter::add_variable(
		std::string const& 
	) {
		// nothing to do.  We do not report values for unused variables.
	}

	void DBOutputter::create_new_variant( genfile::SNPIdentifyingData2 const& snp ) {
		// nothing to do.
	}

	void DBOutputter::store_per_variant_data(
		genfile::SNPIdentifyingData2 const& snp,
		std::string const& variable,
		genfile::VariantEntry const& value
	) {
		m_data.resize( m_data.size() + 1 ) ;
		m_data.back().get<0>() = snp ;
		m_data.back().get<1>() = variable ;
		m_data.back().get<2>() = value ;

		if( m_data.size() == m_max_transaction_count ) {
			write_data( m_data ) ;
			m_data.clear() ;
		}
	}

	void DBOutputter::write_data( Data const& data ) {
		db::Connection::ScopedTransactionPtr transaction = m_outputter.connection().open_transaction( 240 ) ; // wait 4 minutes if we have to.

		if( !transaction.get() ) {
			throw genfile::OperationFailedError( "SNPSummaryComponent::DBOutputter::write_data()", m_outputter.connection().get_spec(), "Opening transaction." ) ;
		}
		
		std::vector< db::Connection::RowId > snp_ids( data.size() ) ;
		for( std::size_t i = 0; i < data.size(); ++i ) {
			// Common usage is to record many variables for each SNP, so optimise for that usage.
			// i.e. only try to make a new variant if it differs from the previous one.
			if( i == 0 || data[i].get<0>() != data[i-1].get<0>() ) {
				snp_ids[i] = m_outputter.get_or_create_variant( data[i].get<0>() ) ;
			}
			else {
				snp_ids[i] = snp_ids[i-1] ;
			}
		}
		for( std::size_t i = 0; i < data.size(); ++i ) {
			store_data(
				snp_ids[i],
				data[i].get<1>(),
				data[i].get<2>()
			) ;
		}
	}

	void DBOutputter::store_data(
		db::Connection::RowId const snp_id,
		std::string const& variable,
		genfile::VariantEntry const& value
	) {
		db::Connection::RowId variable_id = m_outputter.get_or_create_entity( variable, variable, m_variable_id ) ;
		m_outputter.insert_summary_data( snp_id, variable_id, value ) ;
	}
}
